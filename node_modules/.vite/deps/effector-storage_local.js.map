{
  "version": 3,
  "sources": ["../../.pnpm/effector-storage@5.0.1_effector@22.5.0/node_modules/src/area.ts", "../../.pnpm/effector-storage@5.0.1_effector@22.5.0/node_modules/src/persist.ts", "../../.pnpm/effector-storage@5.0.1_effector@22.5.0/node_modules/src/index.ts", "../../.pnpm/effector-storage@5.0.1_effector@22.5.0/node_modules/src/nil/index.ts", "../../.pnpm/effector-storage@5.0.1_effector@22.5.0/node_modules/src/storage/index.ts", "../../.pnpm/effector-storage@5.0.1_effector@22.5.0/node_modules/src/local/index.ts"],
  "sourcesContent": ["import type { Store } from 'effector'\nimport { createStore } from 'effector'\n\n/**\n * Keys areas / namespaces cache\n */\nconst areas = new Map<any, Map<string, Store<any>>>()\n\n/**\n * Get store, responsible for the key in key area / namespace\n */\nexport function getAreaStorage<State>(keyArea: any, key: string): Store<State> {\n  let area = areas.get(keyArea)\n  if (area === undefined) {\n    area = new Map()\n    areas.set(keyArea, area)\n  }\n\n  let store = area.get(key)\n  if (store !== undefined) {\n    return store\n  }\n\n  // @ts-expect-error due to old typings in import\n  store = createStore(null, { serialize: 'ignore' })\n  area.set(key, store)\n\n  return store\n}\n", "import type { Subscription } from 'effector'\nimport type {\n  ConfigPersist,\n  ConfigSourceTarget,\n  ConfigStore,\n  Done,\n  Fail,\n  Finally,\n} from './types'\nimport {\n  clearNode,\n  createEffect,\n  createEvent,\n  createNode,\n  forward,\n  guard,\n  is,\n  sample,\n  withRegion,\n} from 'effector'\nimport { getAreaStorage } from './area'\n\n/**\n * Default sink for unhandled errors\n */\nconst sink = createEvent<Fail<any>>()\nsink.watch((payload) => console.error(payload.error))\n\n/**\n * Main `persist` function\n */\nexport function persist<State, Err = Error>({\n  adapter,\n  store,\n  source = store,\n  target = store,\n  clock = source,\n  done,\n  fail = sink,\n  finally: anyway,\n  pickup,\n  key: keyName,\n  keyPrefix = '',\n}: Partial<\n  ConfigPersist & ConfigStore<State, Err> & ConfigSourceTarget<State, Err>\n>): Subscription {\n  if (!adapter) {\n    throw Error('Adapter is not defined')\n  }\n  if (!source) {\n    throw Error('Store or source is not defined')\n  }\n  if (!target) {\n    throw Error('Target is not defined')\n  }\n  if (!keyName && source.shortName === (source as any).id) {\n    throw Error('Key or name is not defined')\n  }\n  if (source === target && !is.store(source)) {\n    throw Error('Source must be different from target')\n  }\n\n  const key = keyName || source.shortName\n  const storage = getAreaStorage<State>(\n    adapter.keyArea || adapter,\n    keyPrefix + key\n  )\n  const region = createNode()\n  const desist = () => clearNode(region)\n\n  const op =\n    (operation: 'get' | 'set') =>\n    ({ status, params, result, error }: any): any =>\n      status === 'done'\n        ? {\n            status,\n            key,\n            keyPrefix,\n            operation,\n            value: operation === 'get' ? result : params,\n          }\n        : {\n            status,\n            key,\n            keyPrefix,\n            operation,\n            value: params,\n            error,\n          }\n\n  // create all auxiliary units and nodes within the region,\n  // to be able to remove them all at once on unsubscription\n  withRegion(region, () => {\n    const getFx = createEffect<void, State, Err>()\n    const setFx = createEffect<State, void, Err>()\n\n    const localAnyway = createEvent<Finally<State, Err>>()\n    const localDone = localAnyway.filterMap<Done<State>>(\n      ({ status, key, keyPrefix, operation, value }) =>\n        status === 'done' ? { key, keyPrefix, operation, value } : undefined\n    )\n    const localFail = localAnyway.filterMap<Fail<Err>>(\n      ({ status, key, keyPrefix, operation, error, value }: any) =>\n        status === 'fail'\n          ? { key, keyPrefix, operation, error, value }\n          : undefined\n    )\n\n    const value = adapter<State>(keyPrefix + key, getFx)\n    getFx.use(value.get)\n    setFx.use(value.set)\n\n    const trigger = createEvent<State>()\n    sample({\n      source,\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      clock: clock!, // `clock` is always defined, as long as `source` is defined\n      target: trigger,\n    })\n\n    guard({\n      source: sample<State, State, [State, State]>(\n        storage,\n        trigger,\n        (current, proposed) => [proposed, current]\n      ),\n      filter: ([proposed, current]) => proposed !== current,\n      target: setFx.prepend<[State, State]>(([proposed]) => proposed),\n    })\n    forward({ from: [getFx.doneData, setFx], to: storage })\n    forward({ from: [getFx.doneData, storage], to: target })\n    forward({\n      from: [getFx.finally.map(op('get')), setFx.finally.map(op('set'))],\n      to: localAnyway,\n    })\n\n    forward({ from: localFail, to: fail })\n    if (done) forward({ from: localDone, to: done })\n    if (anyway) forward({ from: localAnyway, to: anyway })\n\n    if (pickup) {\n      // pick up value from storage ONLY on `pickup` update\n      forward({ from: pickup, to: getFx.prepend(() => undefined) })\n    } else {\n      // kick getter to pick up initial value from storage\n      getFx()\n    }\n  })\n\n  return (desist.unsubscribe = desist)\n}\n", "import type { ConfigPersist, Persist } from './types'\nimport { persist as base } from './persist'\n\nexport type {\n  ConfigPersist,\n  ConfigSourceTarget,\n  ConfigStore,\n  Done,\n  Fail,\n  Finally,\n  Persist,\n  StorageAdapter,\n} from './types'\n\n/**\n * Creates custom `persist`\n */\nexport function createPersist(defaults?: ConfigPersist): Persist {\n  return (config) => base({ ...defaults, ...config })\n}\n\n/**\n * Default `persist`\n */\nexport const persist = createPersist()\n", "import type { StorageAdapter } from '..'\n\n/**\n * Nil/Void adapter\n */\nexport function nil(keyArea?: any): StorageAdapter {\n  const adapter: StorageAdapter = () =>\n    <any>{\n      get() {}, // eslint-disable-line @typescript-eslint/no-empty-function\n      set() {}, // eslint-disable-line @typescript-eslint/no-empty-function\n    }\n\n  adapter.keyArea = keyArea\n  return adapter\n}\n", "import type { StorageAdapter } from '..'\n\nexport interface StorageConfig {\n  storage: Storage\n  sync?: boolean\n  serialize?: (value: any) => string\n  deserialize?: (value: string) => any\n}\n\n/**\n * Generic `Storage` adapter factory\n */\nexport function storage({\n  storage,\n  sync = false,\n  serialize = JSON.stringify,\n  deserialize = JSON.parse,\n}: StorageConfig): StorageAdapter {\n  const adapter: StorageAdapter = <State>(\n    key: string,\n    update: (raw?: any) => any\n  ) => {\n    if (sync && typeof addEventListener !== 'undefined') {\n      addEventListener('storage', (e) => {\n        if (e.storageArea === storage) {\n          if (e.key === key) update(e.newValue)\n\n          // `key` attribute is `null` when the change is caused by the storage `clear()` method\n          if (e.key === null) update(null)\n        }\n      })\n    }\n\n    return {\n      get(value?: string | null) {\n        const item = value !== undefined ? value : storage.getItem(key)\n        return value === undefined && item === null\n          ? undefined\n          : deserialize(item as any)\n      },\n\n      set(value: State) {\n        storage.setItem(key, serialize(value))\n      },\n    }\n  }\n\n  adapter.keyArea = storage\n  return adapter\n}\n", "import type { Subscription } from 'effector'\nimport type {\n  ConfigPersist as BaseConfigPersist,\n  ConfigCommon,\n  ConfigJustStore,\n  ConfigJustSourceTarget,\n} from '../types'\nimport { persist as base } from '../persist'\nimport { nil } from '../nil'\nimport { storage } from '../storage'\n\nexport type { Done, Fail, Finally, StorageAdapter } from '../types'\n\nexport interface ConfigPersist extends BaseConfigPersist {\n  sync?: boolean\n}\n\nexport interface AdapterConfig {\n  sync?: boolean\n  serialize?: (value: any) => string\n  deserialize?: (value: string) => any\n}\n\nexport interface ConfigStore<State, Err = Error>\n  extends AdapterConfig,\n    ConfigCommon<State, Err>,\n    ConfigJustStore<State> {}\n\nexport interface ConfigSourceTarget<State, Err = Error>\n  extends AdapterConfig,\n    ConfigCommon<State, Err>,\n    ConfigJustSourceTarget<State> {}\n\nexport interface Persist {\n  <State, Err = Error>(config: ConfigSourceTarget<State, Err>): Subscription\n  <State, Err = Error>(config: ConfigStore<State, Err>): Subscription\n}\n\n/**\n * Function, checking if `localStorage` exists and accessible\n */\nfunction supports() {\n  try {\n    return typeof localStorage !== 'undefined'\n  } catch (error) {\n    return false // should somehow return error instance?\n  }\n}\n\n/**\n * Creates custom partially applied `persist`\n * with predefined `localStorage` adapter\n */\nexport function createPersist(defaults?: ConfigPersist): Persist {\n  return (config) =>\n    base({\n      adapter: supports()\n        ? storage({\n            storage: localStorage,\n            sync: true,\n            ...defaults,\n            ...config,\n          })\n        : nil('local'),\n      ...defaults,\n      ...config,\n    })\n}\n\n/**\n * Default partially applied `persist`\n */\nexport const persist = createPersist()\n"],
  "mappings": "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",
  "names": ["areas", "Map", "sink", "createEvent", "createPersist", "defaults", "config", "adapter", "store", "source", "target", "clock", "done", "fail", "finally", "anyway", "pickup", "key", "keyName", "keyPrefix", "Error", "shortName", "id", "is", "storage", "keyArea", "area", "get", "set", "createStore", "serialize", "region", "createNode", "desist", "clearNode", "op", "operation", "status", "params", "result", "error", "value", "withRegion", "getFx", "createEffect", "setFx", "localAnyway", "localDone", "filterMap", "undefined", "localFail", "use", "trigger", "sample", "guard", "current", "proposed", "filter", "prepend", "forward", "from", "doneData", "to", "map", "unsubscribe", "watch", "payload", "console", "persist", "nil", "keyArea", "adapter", "get", "set", "storage", "sync", "serialize", "JSON", "stringify", "deserialize", "parse", "adapter", "key", "update", "addEventListener", "e", "storageArea", "newValue", "get", "value", "item", "getItem", "set", "setItem", "keyArea", "supports", "localStorage", "error", "createPersist", "defaults", "config", "base", "adapter", "storage", "sync", "nil", "persist"]
}
