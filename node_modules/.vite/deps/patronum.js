import {
  $,
  M,
  Pe,
  S,
  a,
  ae,
  b,
  d,
  j,
  m,
  mt,
  n,
  p,
  y,
  yt,
  z
} from "./chunk-RGWNF6XI.js";
import "./chunk-TFWDKVI3.js";

// node_modules/.pnpm/patronum@1.15.0_effector@22.5.0/node_modules/patronum/and/index.js
function and() {
  for (var _len = arguments.length, stores = new Array(_len), _key = 0; _key < _len; _key++) {
    stores[_key] = arguments[_key];
  }
  return m({
    and: [stores, (values) => {
      for (var value of values) {
        if (!value) {
          return false;
        }
      }
      return true;
    }],
    or: {
      sid: "-rbm5ks"
    }
  });
}

// node_modules/.pnpm/patronum@1.15.0_effector@22.5.0/node_modules/patronum/combine-events/index.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function combineEvents(_ref) {
  var {
    events,
    reset: reset2,
    target = d({
      name: "target",
      sid: "3pez5"
    }, {
      name: "target",
      sid: "3pez5"
    })
  } = _ref;
  if (!ae.unit(target))
    throwError("target should be a unit");
  if (reset2 && !ae.unit(reset2))
    throwError("reset should be a unit");
  n(target, () => {
    var keys = Object.keys(events);
    var defaultShape = Array.isArray(events) ? [...keys].fill("") : {};
    var $counter = p(keys.length, {
      and: {
        serialize: "ignore"
      },
      name: "$counter",
      sid: "-dszn9a"
    });
    var $results = p(defaultShape, {
      and: {
        serialize: "ignore"
      },
      name: "$results",
      sid: "boz3x7"
    });
    $counter.reset(z({
      and: [{
        source: target
      }],
      or: {
        sid: "-8yzcn6"
      }
    }));
    $results.reset(target);
    if (reset2) {
      $counter.reset(z({
        and: [{
          source: reset2
        }],
        or: {
          sid: "-72suil"
        }
      }));
      $results.reset(reset2);
    }
    var _loop = function _loop2(key2) {
      var $isDone = p(false, {
        and: {
          serialize: "ignore"
        },
        name: "$isDone",
        sid: "ucs7nc"
      }).on(events[key2], () => true).reset(target);
      if (reset2) {
        $isDone.reset(reset2);
      }
      $counter.on($isDone, (value) => value - 1);
      $results.on(events[key2], (shape, payload) => {
        var newShape = Array.isArray(shape) ? [...shape] : _objectSpread({}, shape);
        newShape[key2] = payload;
        return newShape;
      });
    };
    for (var key of keys) {
      _loop(key);
    }
    M({
      and: [{
        source: z({
          and: [{
            source: $results,
            clock: S(Object.values(events), {
              name: "clock",
              sid: "-5k316x"
            })
          }],
          or: {
            name: "source",
            sid: "uf92v9"
          }
        }),
        filter: $counter.map((value) => value === 0),
        target
      }],
      or: {
        sid: "ciekm0"
      }
    });
  });
  return target;
}
function throwError(message) {
  throw new Error(message);
}

// node_modules/.pnpm/patronum@1.15.0_effector@22.5.0/node_modules/patronum/condition/index.js
function condition(_ref) {
  var {
    if: test,
    then: thenBranch,
    else: elseBranch,
    source = d({
      name: "source",
      sid: "epke23"
    }, {
      name: "source",
      sid: "epke23"
    })
  } = _ref;
  var checker = ae.unit(test) || isFunction(test) ? test : (value) => value === test;
  if (thenBranch && elseBranch) {
    j({
      and: [{
        source,
        match: {
          then: checker,
          else: inverse(checker)
        },
        cases: {
          then: thenBranch,
          else: elseBranch
        }
      }],
      or: {
        sid: "9tug3k"
      }
    });
  } else if (thenBranch) {
    M({
      and: [{
        source,
        filter: checker,
        target: thenBranch
      }],
      or: {
        sid: "abznoh"
      }
    });
  } else if (elseBranch) {
    M({
      and: [{
        source,
        filter: inverse(checker),
        target: elseBranch
      }],
      or: {
        sid: "-eb29qp"
      }
    });
  }
  return source;
}
function isFunction(value) {
  return typeof value === "function";
}
function inverse(fnOrUnit) {
  if (ae.unit(fnOrUnit)) {
    return fnOrUnit.map((value) => !value);
  }
  return (value) => !fnOrUnit(value);
}

// node_modules/.pnpm/patronum@1.15.0_effector@22.5.0/node_modules/patronum/debounce/index.js
function debounce(_ref) {
  var {
    source,
    timeout,
    target
  } = _ref;
  if (!ae.unit(source))
    throw new TypeError("source must be unit from effector");
  if (ae.domain(source, {
    sid: "jnxv16"
  }))
    throw new TypeError("source cannot be domain");
  var $timeout = toStoreNumber(timeout);
  var saveTimeoutId = d({
    name: "saveTimeoutId",
    sid: "f7vear"
  });
  var $timeoutId = p(null, {
    and: {
      serialize: "ignore"
    },
    name: "$timeoutId",
    sid: "-50jqki"
  }).on(saveTimeoutId, (_, id) => id);
  var saveReject = d({
    name: "saveReject",
    sid: "-5595t"
  });
  var $rejecter = p(null, {
    and: {
      serialize: "ignore"
    },
    name: "$rejecter",
    sid: "u7x1h9"
  }).on(saveReject, (_, rj) => rj);
  var tick = target !== null && target !== void 0 ? target : d({
    name: "tick",
    sid: "-6fizi7"
  });
  var timerBaseFx = y((_ref2) => {
    var {
      timeout: timeout2,
      timeoutId,
      rejectPromise
    } = _ref2;
    if (timeoutId)
      clearTimeout(timeoutId);
    if (rejectPromise)
      rejectPromise();
    return new Promise((resolve, reject) => {
      saveReject(reject);
      saveTimeoutId(setTimeout(resolve, timeout2));
    });
  }, {
    name: "timerBaseFx",
    sid: "-ww7mc3"
  });
  var timerFx = b({
    and: {
      source: {
        timeoutId: $timeoutId,
        rejectPromise: $rejecter
      },
      mapParams: (timeout2, _ref3) => {
        var {
          timeoutId,
          rejectPromise
        } = _ref3;
        return {
          timeout: timeout2,
          timeoutId,
          rejectPromise
        };
      },
      effect: timerBaseFx
    },
    or: {
      name: "timerFx",
      sid: "-4ab544"
    }
  });
  $rejecter.reset(timerFx.done);
  $timeoutId.reset(timerFx.done);
  var $payload = p([], {
    and: {
      serialize: "ignore"
    },
    name: "$payload",
    sid: "-5sqiq6"
  }).on(source, (_, payload) => [payload]);
  var $canTick = p(true, {
    and: {
      serialize: "ignore"
    },
    name: "$canTick",
    sid: "-ytfpys"
  });
  var triggerTick = d({
    name: "triggerTick",
    sid: "aamdmm"
  });
  $canTick.on(triggerTick, () => false).on([
    tick,
    // debounce timeout should be restarted on timeout change
    $timeout,
    // debounce timeout can be restarted in later ticks
    timerFx
  ], () => true);
  var requestTick = S([
    source,
    // debounce timeout is restarted on timeout change
    $timeout
  ], {
    name: "requestTick",
    sid: "-8mwak3"
  });
  M({
    and: [{
      clock: requestTick,
      filter: $canTick,
      target: triggerTick
    }],
    or: {
      sid: "-2h4urv"
    }
  });
  z({
    and: [{
      source: $timeout,
      clock: triggerTick,
      target: timerFx
    }],
    or: {
      sid: "-22aer4"
    }
  });
  z({
    and: [{
      source: $payload,
      clock: timerFx.done,
      fn: (_ref4) => {
        var [payload] = _ref4;
        return payload;
      },
      target: tick
    }],
    or: {
      sid: "-1nfyqd"
    }
  });
  return tick;
}
function toStoreNumber(value) {
  if (ae.store(value, {
    sid: "-15ujnd"
  }))
    return value;
  if (typeof value === "number") {
    if (value < 0 || !Number.isFinite(value))
      throw new Error('timeout must be positive number or zero. Received: "'.concat(value, '"'));
    return p(value, {
      and: {
        name: "$timeout"
      },
      sid: "-x71bft"
    });
  }
  throw new TypeError('timeout parameter in interval method should be number or Store. "'.concat(typeof value, '" was passed'));
}

// node_modules/.pnpm/patronum@1.15.0_effector@22.5.0/node_modules/patronum/debug/index.js
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty2(obj, key, value) {
  key = _toPropertyKey2(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey2(arg) {
  var key = _toPrimitive2(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive2(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var defaultConfig = {
  trace: false,
  // default logger to console.info
  handler: (context) => {
    if (isEffectChild(context.node) && context.node.meta.named === "finally") {
      return;
    }
    var {
      scope,
      scopeName,
      name,
      kind,
      value,
      loc,
      trace,
      node,
      logType
    } = context;
    var scopeLog = scope ? " (scope: ".concat(scopeName, ")") : "";
    var logName = name !== null && name !== void 0 ? name : loc ? "".concat(loc.file, ":").concat(loc.line, ":").concat(loc.column) : "";
    var logPrintType = logType === "initial" ? " [getState]" : "";
    console.info("[".concat(kind, "]").concat(scopeLog, " ").concat(logName).concat(logPrintType), value);
    if (
      // logging trace only if there is something to log
      trace && trace.length > 0 && // do not log trace for effect children, as it is always the same effect internals
      !isEffectChild(node)
    ) {
      console.groupCollapsed("[".concat(kind, "]").concat(scopeLog, " ").concat(logName, " trace"));
      trace.forEach((update) => {
        var {
          name: traceName,
          kind: kind2,
          value: value2,
          loc: loc2
        } = update;
        var logTraceName = traceName !== null && traceName !== void 0 ? traceName : loc2 ? "".concat(loc2.file, ":").concat(loc2.line, ":").concat(loc2.column) : "";
        console.info("<- [".concat(kind2, "] ").concat(logTraceName), value2);
      });
      console.groupEnd();
    }
  }
};
function debug() {
  var {
    config,
    units
  } = resolveParams(...arguments);
  units.forEach((unit) => {
    if (ae.store(unit, {
      sid: "-foynff"
    }) || ae.event(unit, {
      sid: "apy28p"
    }) || ae.effect(unit, {
      sid: "apy3od"
    })) {
      watchUnit(unit, config);
    } else if (ae.domain(unit, {
      sid: "-rsqe9t"
    })) {
      watchDomain(unit, config);
    } else {
    }
  });
}
function watchDomain(domain, config) {
  domain.onCreateStore((store) => watchUnit(store, config));
  domain.onCreateEvent((event) => watchUnit(event, config));
  domain.onCreateEffect((effect) => watchUnit(effect, config));
  domain.onCreateDomain((domain2) => watchDomain(domain2, config));
}
function watchUnit(unit, config) {
  if (ae.store(unit, {
    sid: "w7ds2s"
  })) {
    watchStoreInit(unit, config);
    watch(unit, config);
  } else if (ae.event(unit, {
    sid: "fretyd"
  })) {
    watch(unit, config);
  } else if (ae.effect(unit, {
    sid: "gpi2qr"
  })) {
    watch(unit, config);
    watch(unit.finally, config);
    watch(unit.done, config);
    watch(unit.fail, config);
  }
}
function watch(unit, config) {
  var watcher = a({
    parent: [unit],
    // debug watchers should behave like normal watchers
    meta: {
      op: "watch"
    },
    family: {
      owners: unit
    },
    regional: true,
    // node only gets all required data
    node: [Pe.run({
      fn(value, _internal, stack) {
        var _stack$scope;
        var scope = (_stack$scope = stack === null || stack === void 0 ? void 0 : stack.scope) !== null && _stack$scope !== void 0 ? _stack$scope : null;
        var context = {
          logType: "update",
          scope,
          scopeName: getScopeName(scope),
          node: getNode(unit),
          kind: getType(unit),
          value,
          name: getName(unit),
          loc: getLoc(unit),
          // Use stack meta of actual unit, not of debug node
          stackMeta: getStackMeta(stack.parent),
          trace: config.trace ? collectTrace(stack) : []
        };
        if (!config.handler) {
          throw Error("patronum/debug must have the handler");
        }
        config.handler(context);
      }
    })]
  });
  return () => mt(watcher);
}
function collectTrace(stack) {
  var trace = [];
  var parent = stack === null || stack === void 0 ? void 0 : stack.parent;
  while (parent) {
    var {
      node,
      value
    } = parent;
    var entry = {
      node,
      value,
      name: getName(node),
      loc: getLoc(node),
      kind: getType(node),
      stackMeta: getStackMeta(parent)
    };
    trace.push(entry);
    parent = parent.parent;
  }
  return trace;
}
function watchStoreInit(store, config) {
  if (!config.handler) {
    throw Error("patronum/debug must have the handler");
  }
  var node = getNode(store);
  var context = {
    logType: "initial",
    scope: null,
    scopeName: null,
    node,
    kind: getType(store),
    value: store.getState(),
    name: getName(store),
    loc: getLoc(store),
    // nothing to trace for store.getState() - it is one-step call
    trace: [],
    // no stackMeta for initial state
    stackMeta: {}
  };
  config.handler(context);
  scopes.forEach((scope) => watchStoreInitInScope(store, config, scope));
  watchScopeRegister((newScope) => watchStoreInitInScope(store, config, newScope));
}
function watchStoreInitInScope(store, config, scope) {
  if (!config.handler) {
    throw Error("patronum/debug must have the handler");
  }
  var node = getNode(store);
  var context = {
    logType: "initial",
    scope,
    scopeName: getScopeName(scope),
    node,
    kind: getType(store),
    value: scope.getState(store),
    name: getName(store),
    loc: getLoc(store),
    // nothing to trace for scope.getState(store) - it is one-step call
    trace: [],
    // no stackMeta for initial state
    stackMeta: {}
  };
  config.handler(context);
}
function resolveParams() {
  var config = defaultConfig;
  for (var _len = arguments.length, entry = new Array(_len), _key = 0; _key < _len; _key++) {
    entry[_key] = arguments[_key];
  }
  var [maybeConfig, ...restUnits] = entry;
  var units = [];
  if (isConfig(maybeConfig)) {
    config = _objectSpread2(_objectSpread2({}, defaultConfig), maybeConfig);
  } else if (!ae.unit(maybeConfig)) {
    for (var [name, unit] of Object.entries(maybeConfig)) {
      customNames.set(getGraph(unit).id, name);
      units.push(unit);
    }
  } else {
    units.push(maybeConfig);
  }
  for (var maybeUnit of restUnits) {
    if (ae.unit(maybeUnit)) {
      units.push(maybeUnit);
    } else {
      for (var [_name, _unit] of Object.entries(maybeUnit)) {
        customNames.set(getGraph(_unit).id, _name);
        units.push(_unit);
      }
    }
  }
  return {
    config,
    units
  };
}
function isConfig(maybeConfig) {
  if (!ae.unit(maybeConfig)) {
    return !Object.values(maybeConfig).every(ae.unit);
  }
  return false;
}
var watchers = /* @__PURE__ */ new Set();
var watchScopeRegister = (cb) => {
  watchers.add(cb);
  return () => {
    watchers.delete(cb);
  };
};
function registerScope(scope, config) {
  scopes.save(scope, {
    name: config.name
  });
  watchers.forEach((cb) => cb(scope));
  return () => {
    scopes.delete(scope);
  };
}
function unregisterAllScopes() {
  scopes.clear();
}
var unknownScopes = 0;
function getDefaultScopeName() {
  unknownScopes += 1;
  return "unknown_".concat(unknownScopes);
}
var cache = /* @__PURE__ */ new Map();
var scopes = {
  save(scope, meta) {
    if (!scopes.get(scope)) {
      cache.set(scope, meta);
    }
  },
  get(scope) {
    var _cache$get;
    if (!scope)
      return null;
    return (_cache$get = cache.get(scope)) !== null && _cache$get !== void 0 ? _cache$get : null;
  },
  delete(scope) {
    cache.delete(scope);
  },
  forEach(callback) {
    cache.forEach((meta, scope) => callback(scope, meta));
  },
  clear() {
    cache.clear();
  }
};
debug.registerScope = registerScope;
debug.unregisterAllScopes = unregisterAllScopes;
function getScopeName(scope) {
  if (!scope)
    return null;
  var meta = scopes.get(scope);
  if (!meta) {
    var fallbackId = scope._debugId || (scope._debugId = getDefaultScopeName());
    return fallbackId;
  }
  return meta.name;
}
function isEffectChild(node) {
  var actualNode = getNode(node);
  var {
    sid,
    named
  } = actualNode.meta;
  return Boolean(!sid && (named === "finally" || named === "done" || named === "doneData" || named === "fail" || named === "failData" || named === "inFlight" || named === "pending"));
}
function isStoreOn(node) {
  var actualNode = getNode(node);
  var {
    op
  } = actualNode.meta;
  if (op === "on")
    return true;
  return false;
}
function getType(unit) {
  if (ae.store(unit, {
    sid: "4o7s04"
  })) {
    return "store";
  }
  if (ae.effect(unit, {
    sid: "4pv5s7"
  }) || isEffectChild(unit)) {
    return "effect";
  }
  if (ae.event(unit, {
    sid: "4rijka"
  })) {
    return "event";
  }
  if (ae.domain(unit, {
    sid: "54plsy"
  })) {
    return "domain";
  }
  if (ae.unit(unit)) {
    return "unit";
  }
  var node = getNode(unit);
  if (node.meta.op) {
    return node.meta.op;
  }
  return "unknown";
}
var getGraph = (graph) => graph.graphite || graph;
var customNames = /* @__PURE__ */ new Map();
function getName(unit) {
  var _getNode, _getNode$meta;
  var custom = customNames.get(getGraph(unit).id);
  if (custom) {
    return custom;
  }
  if (isEffectChild(unit)) {
    var node = getNode(unit);
    var parentEffect = node.family.owners.find((n2) => n2.meta.op === "effect");
    if (parentEffect) {
      var closestParentDomainName = getOwningDomainName(parentEffect);
      var formattedDomainName = closestParentDomainName ? "".concat(closestParentDomainName, "/") : "";
      return "".concat(formattedDomainName).concat(getName(parentEffect), ".").concat(node.meta.named);
    }
    return node.meta.named;
  }
  if (isStoreOn(unit)) {
    var _node = getNode(unit);
    var targetStoreName = getName(_node.next[0]);
    var triggerEventName = getName(_node.family.owners[0]);
    return "".concat(targetStoreName, ".on(").concat(triggerEventName, ")");
  }
  if (ae.unit(unit)) {
    var _compositeName;
    if (unit !== null && unit !== void 0 && (_compositeName = unit.compositeName) !== null && _compositeName !== void 0 && _compositeName.fullName) {
      return unit.compositeName.fullName;
    }
    var _closestParentDomainName = getOwningDomainName(unit);
    var _formattedDomainName = _closestParentDomainName ? "".concat(_closestParentDomainName, "/") : "";
    if (unit !== null && unit !== void 0 && unit.shortName) {
      return "".concat(_formattedDomainName).concat(unit.shortName);
    }
    if (unit !== null && unit !== void 0 && unit.name) {
      return "".concat(_formattedDomainName).concat(unit.name);
    }
  }
  if ((_getNode = getNode(unit)) !== null && _getNode !== void 0 && (_getNode$meta = _getNode.meta) !== null && _getNode$meta !== void 0 && _getNode$meta.name) {
    return getNode(unit).meta.name;
  }
  return null;
}
function getOwningDomainName(unit) {
  var closestParentDomain = getNode(unit).family.owners.find((n2) => n2.meta.op === "domain");
  if (!closestParentDomain)
    return null;
  return getName(closestParentDomain);
}
function readLoc(_ref) {
  var {
    meta
  } = _ref;
  var loc = "config" in meta ? meta.config.loc : meta.loc;
  return loc;
}
function getLoc(unit) {
  var loc = readLoc(getNode(unit));
  if (!loc)
    return void 0;
  return loc;
}
function getNode(node) {
  var actualNode = "graphite" in node ? node.graphite : node;
  return actualNode;
}
function getStackMeta(stack) {
  if (!stack)
    return {};
  var meta = stack.meta || {};
  return meta;
}

// node_modules/.pnpm/patronum@1.15.0_effector@22.5.0/node_modules/patronum/delay/index.js
function delay(_ref) {
  var {
    source,
    timeout,
    target = d({
      name: "target",
      sid: "-z2vw3w"
    }, {
      name: "target",
      sid: "-z2vw3w"
    })
  } = _ref;
  if (!ae.unit(source))
    throw new TypeError("source must be a unit from effector");
  if (!ae.unit(target))
    throw new TypeError("target must be a unit from effector");
  var ms = validateTimeout(timeout);
  var timerFx = y((_ref2) => {
    var {
      payload,
      milliseconds
    } = _ref2;
    return new Promise((resolve) => {
      setTimeout(resolve, milliseconds, payload);
    });
  }, {
    name: "timerFx",
    sid: "-584o7j"
  });
  z({
    and: [{
      // ms can be Store<number> | number
      // converts object of stores or object of values to store
      source: m({
        and: [{
          milliseconds: ms
        }],
        or: {
          name: "source",
          sid: "9rbdjo"
        }
      }),
      clock: source,
      fn: (_ref3, payload) => {
        var {
          milliseconds
        } = _ref3;
        return {
          payload,
          milliseconds: typeof milliseconds === "function" ? milliseconds(payload) : milliseconds
        };
      },
      target: timerFx
    }],
    or: {
      sid: "-wmj29s"
    }
  });
  yt({
    and: {
      from: timerFx.doneData,
      to: target
    },
    or: {
      sid: "-vsadmx"
    }
  });
  return target;
}
function validateTimeout(timeout) {
  if (ae.store(timeout, {
    sid: "-va560a"
  }) || typeof timeout === "function" || typeof timeout === "number") {
    return timeout;
  }
  throw new TypeError(`'timeout' argument must be a function, Store, or a number. Passed "`.concat(typeof timeout, '"'));
}

// node_modules/.pnpm/patronum@1.15.0_effector@22.5.0/node_modules/patronum/either/index.js
function either(filterOptions, then, other) {
  if (ae.store(filterOptions, {
    sid: "ozzvoc"
  })) {
    return m({
      and: [filterOptions, then, other, (filter, then2, other2) => filter ? then2 : other2],
      or: {
        sid: "-5vau2h"
      }
    });
  }
  var objectForm = filterOptions;
  return either(objectForm.filter, objectForm.then, objectForm.other);
}

// node_modules/.pnpm/patronum@1.15.0_effector@22.5.0/node_modules/patronum/empty/index.js
function empty(source) {
  return source.map((value) => value === null);
}

// node_modules/.pnpm/patronum@1.15.0_effector@22.5.0/node_modules/patronum/equals/index.js
function equals(a2, b2) {
  return m({
    and: [a2, b2, (a3, b3) => a3 === b3],
    or: {
      sid: "-pqjlti"
    }
  });
}

// node_modules/.pnpm/patronum@1.15.0_effector@22.5.0/node_modules/patronum/every/index.js
function every(configOrStores, predicateOrNone) {
  var stores = [];
  var predicate = () => false;
  if (Array.isArray(configOrStores)) {
    stores = configOrStores;
    predicate = predicateOrNone;
  } else if (Array.isArray(configOrStores.stores)) {
    stores = configOrStores.stores;
    predicate = configOrStores.predicate;
  }
  var checker;
  if (isFunction2(predicate)) {
    checker = predicate;
  } else if (ae.store(predicate, {
    sid: "sid3ut"
  })) {
    checker = predicate.map((value) => (required) => value === required);
  } else {
    checker = (value) => value === predicate;
  }
  var $values = m({
    and: [stores],
    or: {
      name: "$values",
      sid: "h09uhg"
    }
  });
  var $checker = checker;
  return m({
    and: [$checker, $values, (checker2, values) => values.every(checker2)],
    or: {
      sid: "hfkdw9"
    }
  });
}
function isFunction2(value) {
  return typeof value === "function";
}

// node_modules/.pnpm/patronum@1.15.0_effector@22.5.0/node_modules/patronum/format/index.js
function format(strings) {
  for (var _len = arguments.length, stores = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    stores[_key - 1] = arguments[_key];
  }
  return m({
    and: [stores, (stores2) => strings.reduce((acc, value, index) => acc.concat(isLastElement(strings, index) ? value : "".concat(value).concat(toString(stores2[index]))), "")],
    or: {
      sid: "-yrbthp"
    }
  });
}
function toString(value) {
  if (Array.isArray(value)) {
    return value.map((value2) => String(value2)).join(", ");
  }
  return String(value);
}
function isLastElement(array, index) {
  return index === array.length - 1;
}

// node_modules/.pnpm/patronum@1.15.0_effector@22.5.0/node_modules/patronum/in-flight/index.js
function inFlight(_ref) {
  var {
    effects,
    domain
  } = _ref;
  if (domain) {
    var $inFlight = domain.createStore(0, {
      name: "$inFlight",
      sid: "-y7vg7t"
    });
    domain.onCreateEffect((fx) => {
      $inFlight.on(fx, (count) => count + 1).on(fx.finally, (count) => count - 1);
    });
    return $inFlight;
  }
  return m({
    and: [effects.map((fx) => fx.inFlight), (inFlights) => inFlights.reduce((all, current) => all + current, 0)],
    or: {
      sid: "ubqxa7"
    }
  });
}

// node_modules/.pnpm/patronum@1.15.0_effector@22.5.0/node_modules/patronum/interval/index.js
function interval(_ref) {
  var {
    timeout,
    start,
    stop,
    leading = false,
    trailing = false
  } = _ref;
  var tick = d({
    name: "tick",
    sid: "u782pl"
  });
  var $isRunning = p(false, {
    name: "$isRunning",
    sid: "-xegewf"
  });
  var $timeout = toStoreNumber2(timeout);
  var $notRunning = $isRunning.map((running) => !running);
  var saveTimeout = d({
    name: "saveTimeout",
    sid: "ab3q7d"
  });
  var $timeoutId = p(null, {
    name: "$timeoutId",
    sid: "-aj5rja"
  }).on(saveTimeout, (_, _ref2) => {
    var {
      timeoutId
    } = _ref2;
    return timeoutId;
  });
  var $rejecter = p(() => {
  }, {
    name: "$rejecter",
    sid: "opb0ih"
  }).on(saveTimeout, (_, _ref3) => {
    var {
      reject
    } = _ref3;
    return reject;
  });
  var timeoutFx = b({
    and: {
      source: {
        timeout: $timeout,
        running: $isRunning
      },
      effect: (_ref4) => {
        var {
          timeout: timeout2,
          running
        } = _ref4;
        if (!running) {
          return Promise.reject();
        }
        return new Promise((resolve, reject) => {
          var timeoutId = setTimeout(resolve, timeout2);
          saveTimeout({
            timeoutId,
            reject
          });
        });
      }
    },
    or: {
      name: "timeoutFx",
      sid: "9hil7b"
    }
  });
  var cleanupFx = b({
    and: {
      source: {
        timeoutId: $timeoutId,
        rejecter: $rejecter
      },
      effect: (_ref5) => {
        var {
          timeoutId,
          rejecter
        } = _ref5;
        rejecter();
        if (timeoutId)
          clearTimeout(timeoutId);
      }
    },
    or: {
      name: "cleanupFx",
      sid: "-v02m7d"
    }
  });
  M({
    and: [{
      clock: start,
      source: $timeout,
      filter: $notRunning,
      target: timeoutFx
    }],
    or: {
      sid: "-vop0ii"
    }
  });
  if (leading) {
    var onReady = M({
      and: [{
        clock: start,
        filter: $notRunning
      }],
      or: {
        name: "onReady",
        sid: "-cmw7lh"
      }
    });
    z({
      and: [{
        clock: onReady,
        target: tick
      }],
      or: {
        sid: "-v876ny"
      }
    });
  }
  z({
    and: [{
      clock: start,
      fn: () => true,
      target: $isRunning
    }],
    or: {
      sid: "-v6jsxl"
    }
  });
  M({
    and: [{
      clock: timeoutFx.done,
      source: $timeout,
      filter: $isRunning,
      target: timeoutFx
    }],
    or: {
      sid: "-urpcwu"
    }
  });
  M({
    and: [{
      clock: timeoutFx.done,
      filter: $isRunning,
      target: tick.prepend(() => {
      })
    }],
    or: {
      sid: "-ucb4aq"
    }
  });
  if (stop) {
    if (trailing) {
      z({
        and: [{
          clock: stop,
          target: tick
        }],
        or: {
          sid: "6lcn0o"
        }
      });
    }
    $isRunning.on(stop, () => false);
    z({
      and: [{
        clock: stop,
        target: cleanupFx
      }],
      or: {
        sid: "71ao6f"
      }
    });
  }
  return {
    tick,
    isRunning: $isRunning
  };
}
function toStoreNumber2(value) {
  if (ae.store(value, {
    sid: "7icamc"
  }))
    return value;
  if (typeof value === "number") {
    return p(value, {
      and: {
        name: "$timeout"
      },
      sid: "knc3em"
    });
  }
  throw new TypeError('timeout parameter in interval method should be number or Store. "'.concat(typeof value, '" was passed'));
}

// node_modules/.pnpm/patronum@1.15.0_effector@22.5.0/node_modules/patronum/not/index.js
function not(source) {
  return source.map((value) => !value);
}

// node_modules/.pnpm/patronum@1.15.0_effector@22.5.0/node_modules/patronum/or/index.js
function or() {
  for (var _len = arguments.length, stores = new Array(_len), _key = 0; _key < _len; _key++) {
    stores[_key] = arguments[_key];
  }
  return m({
    and: [stores, (values) => {
      for (var value of values) {
        if (value) {
          return true;
        }
      }
      return false;
    }],
    or: {
      sid: "-44722k"
    }
  });
}

// node_modules/.pnpm/patronum@1.15.0_effector@22.5.0/node_modules/patronum/pending/index.js
var strategies = {
  some: (list) => list.some(Boolean),
  every: (list) => list.every(Boolean)
};
function pending(_ref) {
  var {
    effects: rawEffects,
    domain,
    of = "some"
  } = _ref;
  if (!ae.domain(domain, {
    sid: "97b92c"
  }) && !rawEffects)
    throw new TypeError("domain or effects should be passed");
  if (of !== "some" && of !== "every")
    throw new TypeError('strategy parameter "of" can be "every" or "some". Passed: "'.concat(of, '"'));
  var effects = rawEffects !== null && rawEffects !== void 0 ? rawEffects : [];
  var strategy = strategies[of];
  if (domain) {
    effects = [];
    domain.onCreateEffect((fx) => effects.push(fx));
  }
  return m({
    and: [effects.map((fx) => fx.pending), strategy],
    or: {
      sid: "a37bj0"
    }
  });
}

// node_modules/.pnpm/patronum@1.15.0_effector@22.5.0/node_modules/patronum/reset/index.js
function reset(_ref) {
  var {
    clock,
    target
  } = _ref;
  var targets = Array.isArray(target) ? target : [target];
  var clocks = Array.isArray(clock) ? clock : [clock !== null && clock !== void 0 ? clock : d({
    name: "clocks",
    sid: "bqmea5"
  })];
  targets.forEach((target2) => {
    target2.reset(clocks);
  });
  return clock === void 0 ? clocks[0] : void 0;
}

// node_modules/.pnpm/patronum@1.15.0_effector@22.5.0/node_modules/patronum/reshape/index.js
function reshape(_ref) {
  var {
    source,
    shape
  } = _ref;
  var result = {};
  for (var key in shape) {
    if (key in shape) {
      (function() {
        var fn = shape[key];
        result[key] = source.map((state) => {
          var result2 = fn(state);
          return result2 === void 0 ? null : result2;
        });
      })();
    }
  }
  return result;
}

// node_modules/.pnpm/patronum@1.15.0_effector@22.5.0/node_modules/patronum/snapshot/index.js
function snapshot(_ref) {
  var {
    source,
    clock,
    fn = (value) => value
  } = _ref;
  var defaultValue = fn(source.defaultState);
  var onSnapshot = clock ? z({
    and: [{
      source,
      clock,
      fn
    }],
    or: {
      name: "onSnapshot",
      sid: "-auitd0"
    }
  }) : z({
    and: [{
      source,
      fn
    }],
    or: {
      name: "onSnapshot",
      sid: "-auiql4"
    }
  });
  var $snapshot = p(defaultValue, {
    name: "$snapshot",
    sid: "-7zyoaf"
  });
  $snapshot.on(onSnapshot, (_, value) => value);
  return $snapshot;
}

// node_modules/.pnpm/patronum@1.15.0_effector@22.5.0/node_modules/patronum/some/index.js
function some(configOrStores, predicateOrNone) {
  var stores = [];
  var predicate = () => false;
  if (Array.isArray(configOrStores)) {
    stores = configOrStores;
    predicate = predicateOrNone;
  } else if (Array.isArray(configOrStores.stores)) {
    stores = configOrStores.stores;
    predicate = configOrStores.predicate;
  }
  var checker;
  if (isFunction3(predicate)) {
    checker = predicate;
  } else if (ae.store(predicate, {
    sid: "zbwu0l"
  })) {
    checker = predicate.map((value) => (required) => value === required);
  } else {
    checker = (value) => value === predicate;
  }
  var $values = m({
    and: [stores],
    or: {
      name: "$values",
      sid: "-lv5do0"
    }
  });
  var $checker = checker;
  return m({
    and: [$checker, $values, (checker2, values) => values.some(checker2)],
    or: {
      sid: "-efc5w7"
    }
  });
}
function isFunction3(value) {
  return typeof value === "function";
}

// node_modules/.pnpm/patronum@1.15.0_effector@22.5.0/node_modules/patronum/split-map/index.js
function splitMap(_ref) {
  var {
    source,
    cases
  } = _ref;
  var result = {};
  var current = ae.store(source, {
    name: "current",
    sid: "-htjkz7"
  }) ? source.updates : source;
  for (var key in cases) {
    if (key in cases) {
      (function() {
        var _fn = cases[key];
        result[key] = current.filterMap(_fn);
        current = current.filter({
          fn: (data) => !_fn(data)
        });
      })();
    }
  }
  result.__ = current;
  return result;
}

// node_modules/.pnpm/patronum@1.15.0_effector@22.5.0/node_modules/patronum/spread/index.js
var hasPropBase = {}.hasOwnProperty;
var hasOwnProp = (object, key) => hasPropBase.call(object, key);
function spread(_ref) {
  var {
    targets,
    source = d({
      name: "source",
      sid: "-fkbi3c"
    }, {
      name: "source",
      sid: "-fkbi3c"
    })
  } = _ref;
  var _loop = function _loop2(targetKey2) {
    if (hasOwnProp(targets, targetKey2)) {
      var currentTarget = targets[targetKey2];
      var hasTargetKey = M({
        and: [{
          source,
          greedy: true,
          filter: (object) => typeof object === "object" && object !== null && targetKey2 in object
        }],
        or: {
          name: "hasTargetKey",
          sid: "-cov4g4"
        }
      });
      z({
        and: [{
          greedy: true,
          clock: hasTargetKey,
          fn: (object) => object[targetKey2],
          target: currentTarget
        }],
        or: {
          sid: "lpn34j"
        }
      });
    }
  };
  for (var targetKey in targets) {
    _loop(targetKey);
  }
  return source;
}

// node_modules/.pnpm/patronum@1.15.0_effector@22.5.0/node_modules/patronum/status/index.js
function status(_ref) {
  var {
    effect,
    defaultValue = "initial"
  } = _ref;
  var $status = p(defaultValue, {
    name: "$status",
    sid: "abrgim"
  });
  $status.on(effect, () => "pending").on(effect.done, () => "done").on(effect.fail, () => "fail");
  return $status;
}

// node_modules/.pnpm/patronum@1.15.0_effector@22.5.0/node_modules/patronum/throttle/index.js
function throttle(_ref) {
  var {
    source,
    timeout,
    target = d({
      name: "target",
      sid: "r328r6"
    }, {
      name: "target",
      sid: "r328r6"
    })
  } = _ref;
  if (!ae.unit(source))
    throw new TypeError("source must be unit from effector");
  var $timeout = toStoreNumber3(timeout);
  var timerFx = y((timeout2) => new Promise((resolve) => setTimeout(resolve, timeout2)), {
    name: "timerFx",
    sid: "-pyjx8k"
  });
  var $payload = p(null, {
    and: {
      serialize: "ignore"
    },
    name: "$payload",
    sid: "hinjft"
  }).on(source, (_, payload) => payload);
  var triggerTick = d({
    name: "triggerTick",
    sid: "-sf8sou"
  });
  var $canTick = p(true, {
    and: {
      serialize: "ignore"
    },
    name: "$canTick",
    sid: "-m0cqc"
  }).on(triggerTick, () => false).on(target, () => true);
  M({
    and: [{
      clock: source,
      filter: $canTick,
      target: triggerTick
    }],
    or: {
      sid: "-hzhj9b"
    }
  });
  z({
    and: [{
      source: $timeout,
      clock: triggerTick,
      target: timerFx
    }],
    or: {
      sid: "-hkn38k"
    }
  });
  z({
    and: [{
      source: $payload,
      clock: timerFx.done,
      target
    }],
    or: {
      sid: "-hhcboe"
    }
  });
  return target;
}
function toStoreNumber3(value) {
  if (ae.store(value, {
    sid: "-h0ap6r"
  }))
    return value;
  if (typeof value === "number") {
    if (value < 0 || !Number.isFinite(value))
      throw new Error('timeout must be positive number or zero. Received: "'.concat(value, '"'));
    return p(value, {
      and: {
        name: "$timeout"
      },
      sid: "-h97n10"
    });
  }
  throw new TypeError('timeout parameter should be number or Store. "'.concat(typeof value, '" was passed'));
}

// node_modules/.pnpm/patronum@1.15.0_effector@22.5.0/node_modules/patronum/time/index.js
var defaultNow = () => Date.now();
function time(_ref) {
  var {
    clock,
    getNow,
    initial
  } = _ref;
  var timeReader = getNow !== null && getNow !== void 0 ? getNow : defaultNow;
  var readNowFx = y(timeReader, {
    name: "readNowFx",
    sid: "459ysb"
  });
  var $time = $(readNowFx, initial !== null && initial !== void 0 ? initial : timeReader(), {
    name: "$time",
    sid: "-ys9vce"
  });
  yt({
    and: {
      from: clock,
      to: readNowFx
    },
    or: {
      sid: "rdje9v"
    }
  });
  return $time;
}
export {
  and,
  combineEvents,
  condition,
  debounce,
  debug,
  delay,
  either,
  empty,
  equals,
  every,
  format,
  inFlight,
  interval,
  not,
  or,
  pending,
  reset,
  reshape,
  snapshot,
  some,
  splitMap,
  spread,
  status,
  throttle,
  time
};
//# sourceMappingURL=patronum.js.map
