import {
  O,
  Pe,
  a,
  ae,
  d,
  i,
  m,
  mt,
  p
} from "./chunk-RGWNF6XI.js";
import {
  require_react
} from "./chunk-QSTP2CRO.js";
import {
  __commonJS,
  __toESM
} from "./chunk-TFWDKVI3.js";

// node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React = require_react();
        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function is(x, y2) {
          return x === y2 && (x !== 0 || 1 / x === 1 / y2) || x !== x && y2 !== y2;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useState = React.useState, useEffect = React.useEffect, useLayoutEffect = React.useLayoutEffect, useDebugValue = React.useDebugValue;
        var didWarnOld18Alpha = false;
        var didWarnUncachedGetSnapshot = false;
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          {
            if (!didWarnOld18Alpha) {
              if (React.startTransition !== void 0) {
                didWarnOld18Alpha = true;
                error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
              }
            }
          }
          var value = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedValue = getSnapshot();
              if (!objectIs(value, cachedValue)) {
                error("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var _useState = useState({
            inst: {
              value,
              getSnapshot
            }
          }), inst = _useState[0].inst, forceUpdate = _useState[1];
          useLayoutEffect(function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          }, [subscribe, value, getSnapshot]);
          useEffect(function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            };
            return subscribe(handleStoreChange);
          }, [subscribe]);
          useDebugValue(value);
          return value;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error2) {
            return true;
          }
        }
        function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
          return getSnapshot();
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var isServerEnvironment = !canUseDOM;
        var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;
        var useSyncExternalStore$2 = React.useSyncExternalStore !== void 0 ? React.useSyncExternalStore : shim;
        exports.useSyncExternalStore = useSyncExternalStore$2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
var require_with_selector_development = __commonJS({
  "node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React = require_react();
        var shim = require_shim();
        function is(x, y2) {
          return x === y2 && (x !== 0 || 1 / x === 1 / y2) || x !== x && y2 !== y2;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useSyncExternalStore = shim.useSyncExternalStore;
        var useRef = React.useRef, useEffect = React.useEffect, useMemo = React.useMemo, useDebugValue = React.useDebugValue;
        function useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
          var instRef = useRef(null);
          var inst;
          if (instRef.current === null) {
            inst = {
              hasValue: false,
              value: null
            };
            instRef.current = inst;
          } else {
            inst = instRef.current;
          }
          var _useMemo = useMemo(function() {
            var hasMemo = false;
            var memoizedSnapshot;
            var memoizedSelection;
            var memoizedSelector = function(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                var _nextSelection = selector(nextSnapshot);
                if (isEqual !== void 0) {
                  if (inst.hasValue) {
                    var currentSelection = inst.value;
                    if (isEqual(currentSelection, _nextSelection)) {
                      memoizedSelection = currentSelection;
                      return currentSelection;
                    }
                  }
                }
                memoizedSelection = _nextSelection;
                return _nextSelection;
              }
              var prevSnapshot = memoizedSnapshot;
              var prevSelection = memoizedSelection;
              if (objectIs(prevSnapshot, nextSnapshot)) {
                return prevSelection;
              }
              var nextSelection = selector(nextSnapshot);
              if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {
                return prevSelection;
              }
              memoizedSnapshot = nextSnapshot;
              memoizedSelection = nextSelection;
              return nextSelection;
            };
            var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
            var getSnapshotWithSelector = function() {
              return memoizedSelector(getSnapshot());
            };
            var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {
              return memoizedSelector(maybeGetServerSnapshot());
            };
            return [getSnapshotWithSelector, getServerSnapshotWithSelector];
          }, [getSnapshot, getServerSnapshot, selector, isEqual]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];
          var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);
          useEffect(function() {
            inst.hasValue = true;
            inst.value = value;
          }, [value]);
          useDebugValue(value);
          return value;
        }
        exports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/shim/with-selector.js
var require_with_selector = __commonJS({
  "node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/shim/with-selector.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_with_selector_development();
    }
  }
});

// node_modules/.pnpm/effector-react@22.4.0_h4ij6u274dp7q2sfbxpq3srcnu/node_modules/effector-react/effector-react.mjs
var import_react = __toESM(require_react(), 1);
var import_with_selector = __toESM(require_with_selector(), 1);
var import_shim = __toESM(require_shim(), 1);
function e(e2, t2, n2, r2) {
  let o2 = [Pe.run({ fn: (e3) => t2(e3) })];
  if (r2 && o2.unshift(r2), n2) {
    let t3 = a({ node: o2 }), r3 = e2.graphite.id, u2 = n2.additionalLinks, s2 = u2[r3] || [];
    return u2[r3] = s2, s2.push(t3), () => {
      let e3 = s2.indexOf(t3);
      -1 !== e3 && s2.splice(e3, 1), mt(t3);
    };
  }
  {
    let t3 = a({ node: o2, parent: [e2], family: { owners: e2 } });
    return () => {
      mt(t3);
    };
  }
}
function t(e2, t2) {
  return t2.displayName = e2, t2;
}
function n(t2, n2) {
  ae.store(t2) || E("expect useStore argument to be a store");
  let r2 = import_react.default.useCallback((r3) => e(t2, r3, n2), [t2, n2]), o2 = import_react.default.useCallback(() => M(t2, n2), [t2, n2]);
  return N(r2, o2, o2);
}
function r([t2, n2], r2) {
  let o2, u2, s2, a3, l2 = O2;
  n2 ? (o2 = n2, s2 = t2, a3 = []) : { fn: o2, store: s2, keys: a3, defaultValue: u2, updateFilter: l2 = O2 } = t2, ae.store(s2) || E("useStoreMap expects a store"), Array.isArray(a3) || E("useStoreMap expects an array as keys"), "function" != typeof o2 && E("useStoreMap expects a function");
  let i3 = import_react.default.useCallback((t3) => e(s2, t3, r2), [s2, r2]), c2 = import_react.default.useCallback(() => M(s2, r2), [s2, r2]), f2 = import_react.default.useRef(), p3 = import_react.default.useRef(), d3 = import_react.default.useRef(a3);
  return R(i3, c2, c2, (e2) => {
    if (f2.current !== e2 || !((e3, t3) => {
      if (!e3 || !t3 || e3.length !== t3.length)
        return 0;
      let n3 = 1;
      for (let r3 = 0; r3 < e3.length; r3++)
        if (e3[r3] !== t3[r3]) {
          n3 = 0;
          break;
        }
      return n3;
    })(d3.current, a3)) {
      let t3 = o2(e2, a3);
      void 0 === t3 && void 0 !== u2 && (t3 = u2), f2.current = e2, d3.current = a3, void 0 !== t3 && (p3.current = t3);
    }
    return p3.current;
  }, (e2, t3) => !l2(t3, e2));
}
function o(e2) {
  let t2 = import_react.default.useContext(L);
  return e2 && !t2 && E("No scope found, consider adding <Provider> to app root"), t2;
}
function u(e2, t2) {
  return ((e3, t3) => {
    if (!t3)
      return e3;
    let n2 = ae.unit(e3) || "object" != typeof e3 ? { event: e3 } : e3;
    return import_react.default.useMemo(() => {
      if (ae.unit(e3))
        return O(e3, { scope: t3 });
      let n3 = Array.isArray(e3) ? [] : {};
      for (let r2 in e3)
        n3[r2] = O(e3[r2], { scope: t3 });
      return n3;
    }, [t3, ...Object.keys(n2), ...Object.values(n2)]);
  })(e2, o(null == t2 ? void 0 : t2.forceScope));
}
function s(e2, t2) {
  return n(e2, o(null == t2 ? void 0 : t2.forceScope));
}
function a2(t2, n2) {
  return ((t3, n3) => {
    let r2 = ae.unit(t3), o2 = {};
    r2 ? o2 = { unit: t3 } : "@@unitShape" in t3 ? "function" == typeof t3["@@unitShape"] ? o2 = t3["@@unitShape"]() : E("expect @@unitShape to be a function") : o2 = t3;
    let u2 = Array.isArray(o2), s2 = import_react.default.useRef({ stale: 1, justSubscribed: 0, scope: n3 }), [a3, l2, i3] = import_react.default.useMemo(() => {
      s2.current.stale = 1;
      let e2 = Array.isArray(o2) ? [] : {}, t4 = [], r3 = [];
      for (let u3 in o2) {
        let s3 = o2[u3];
        ae.unit(s3) || E("expect useUnit argument to be a unit"), ae.event(s3) || ae.effect(s3) ? e2[u3] = n3 ? O(s3, { scope: n3 }) : s3 : (e2[u3] = null, t4.push(u3), r3.push(s3));
      }
      return [e2, t4, r3];
    }, [s2, n3, ...Object.keys(o2), ...Object.values(o2)]), c2 = import_react.default.useRef({ value: a3, storeKeys: l2 }), f2 = import_react.default.useCallback((t4) => {
      let r3 = s2.current;
      r3.justSubscribed = 1;
      let o3 = () => {
        r3.stale || (r3.stale = 1, t4());
      }, u3 = Pe.compute({ priority: "sampler", batch: 1 }), a4 = i3.map((t5) => e(t5, o3, n3, u3));
      return () => {
        a4.forEach((e2) => e2());
      };
    }, [i3, n3, c2, s2]), p3 = import_react.default.useCallback(() => {
      let e2, t4 = c2.current, o3 = s2.current, f3 = 0, p4 = t4.value, d3 = t4.storeKeys, m3 = n3 !== o3.scope;
      if ((l2.length > 0 || d3.length > 0) && (o3.stale || o3.justSubscribed || m3)) {
        f3 = !o3.justSubscribed || m3, e2 = u2 ? [...a3] : { ...a3 }, d3.length !== l2.length && (f3 = 1);
        for (let t5 = 0; t5 < l2.length; t5++) {
          let r3 = M(i3[t5], n3), o4 = l2[t5];
          f3 || (f3 = d3.includes(o4) ? p4[o4] !== r3 : 1), e2[o4] = r3;
        }
      }
      return f3 && (t4.value = e2), t4.storeKeys = l2, o3.stale = 0, o3.justSubscribed = !f3, o3.scope = n3, r2 ? t4.value.unit : t4.value;
    }, [f2, i3, n3, c2, s2]);
    return N(f2, p3, p3);
  })(t2, o(null == n2 ? void 0 : n2.forceScope));
}
function l(e2, t2) {
  return r([e2, t2], o(null == e2 ? void 0 : e2.forceScope));
}
function i2(e2, u2, s2) {
  return ((e3, o2, u3) => {
    let s3, a3, l2, i3 = [];
    "object" == typeof o2 && null !== o2 ? (o2.keys && (i3 = o2.keys), { fn: s3, getKey: a3, placeholder: l2 } = o2) : s3 = o2, ae.store(e3) || E("expect useList first argument to be a store"), "function" != typeof s3 && E("expect useList's renderItem to be a function"), Array.isArray(i3) || E("expect useList's keys to be an array");
    let c2 = import_react.default.useMemo(() => {
      let n2 = t(`${e3.shortName || "Unknown"}.Item`, (t2) => {
        let { index: n3, keys: o3, keyVal: s4, value: a4 } = t2;
        if (f2.current[1])
          return f2.current[0](a4, s4);
        let l3 = r([{ store: e3, keys: [n3, ...o3], fn: (e4, t3) => e4[t3[0]] }], u3);
        return f2.current[0](l3, n3);
      });
      return import_react.default.memo(n2);
    }, [e3, u3, !!a3]), f2 = import_react.default.useRef([s3, a3]);
    f2.current = [s3, a3];
    let p3 = import_react.default.useMemo(() => i3, i3);
    if (a3) {
      let t2 = n(e3, u3);
      return 0 === t2.length && l2 ? l2 : t2.map((e4) => {
        let t3 = f2.current[1](e4);
        return import_react.default.createElement(c2, { keyVal: t3, key: t3, keys: p3, value: e4 });
      });
    }
    {
      let t2 = r([{ store: e3, keys: [e3], fn: (e4) => e4.length }], u3);
      return 0 === t2 && l2 ? l2 : Array.from({ length: t2 }, (e4, t3) => import_react.default.createElement(c2, { index: t3, key: t3, keys: p3 }));
    }
  })(e2, u2, o(null == s2 ? void 0 : s2.forceScope));
}
function c(e2, n2) {
  function r2(e3) {
    let t2 = import_react.default.useRef(e3), r3 = s(o2);
    K(() => (a3({ props: t2.current, state: o2.getState() }), () => {
      l2({ props: t2.current, state: o2.getState() });
    }), []);
    let u3 = n2(e3, r3);
    return t2.current = e3, u3;
  }
  let o2;
  ae.store(e2) ? o2 = e2 : "object" == typeof e2 && null !== e2 ? o2 = m(e2) : E("shape should be a store or object with stores");
  let u2 = "Unknown";
  o2 && o2.shortName && (u2 = o2.shortName);
  let a3 = d(), l2 = d();
  return r2.mounted = a3, r2.unmounted = l2, t(`${u2}.View`, r2);
}
function f(e2) {
  return c(e2, ({ children: e3 }, t2) => e3(t2));
}
function p2(e2, t2) {
  let n2 = t2 ? e2 : e2[0];
  var r2;
  ((e3) => {
    if (!e3)
      throw Error("expect first argument be an object");
  })(z(r2 = n2) || ((e3) => "function" == typeof e3)(r2));
  let o2 = n2.or, u2 = n2.and;
  if (u2) {
    let n3 = t2 ? u2 : u2[0];
    if (z(n3) && "and" in n3) {
      let n4 = p2(u2, t2);
      e2 = n4[0], o2 = { ...o2, ...n4[1] };
    } else
      e2 = u2;
  }
  return [e2, o2];
}
function d2(e2, t2 = {}) {
  let n2 = import_react.default.useRef({ value: null, count: 0 });
  K(() => (e2.open(n2.current.value), () => e2.close(n2.current.value)), [e2]), ((e3, t3) => {
    if (e3 === t3)
      return 1;
    if ("object" == typeof e3 && null !== e3 && "object" == typeof t3 && null !== t3) {
      let n3 = Object.keys(e3), r2 = Object.keys(t3);
      if (n3.length !== r2.length)
        return 0;
      for (let r3 = 0; r3 < n3.length; r3++) {
        let o2 = n3[r3];
        if (e3[o2] !== t3[o2])
          return 0;
      }
      return 1;
    }
    return 0;
  })(n2.current.value, t2) || (n2.current.value = t2, n2.current.count += 1), K(() => {
    e2.set(n2.current.value);
  }, [n2.current.count]);
}
function m2(e2, t2) {
  let n2 = t2 && z(r2 = t2[0]) && (r2.and || r2.or) ? t2 : [{ and: t2 }];
  var r2;
  let o2, [[u2, s2], a3] = p2(n2), l2 = {}, i3 = {}, c2 = a3;
  var f2;
  return "string" == typeof u2 ? (i3 = { name: u2 }, z(f2 = s2) && "sid" in f2 || (l2 = s2 || {})) : ((e3) => z(e3) && ("domain" in e3 || "defaultState" in e3 || "name" in e3))(u2) && (i3 = u2, l2 = u2.defaultState || {}, o2 = u2.domain), { hook: e2, domain: o2, defaultState: l2, mainConfig: i3, maybeConfig: c2 };
}
function y(...e2) {
  return (({ domain: e3, defaultState: n2, hook: r2, mainConfig: o2, maybeConfig: u2 }) => {
    function s2(e4) {
      return r2(s2, e4), null;
    }
    let a3 = F({ or: u2, and: o2 }), l2 = `${e3 ? `${e3.compositeName.fullName}/` : ""}${a3.name || "gate"}`, i3 = d({ name: `${l2}.set`, sid: a3.sid ? `${a3.sid}|set` : void 0 }), c2 = d({ name: `${l2}.open`, sid: a3.sid ? `${a3.sid}|open` : void 0 }), f2 = d({ name: `${l2}.close`, sid: a3.sid ? `${a3.sid}|close` : void 0 }), p3 = p(Boolean(0), { name: `${l2}.status`, serialize: "ignore" }).on(c2, () => Boolean(1)).on(f2, () => Boolean(0)), d3 = p(n2, { name: `${l2}.state`, sid: a3.sid }).on(i3, (e4, t2) => t2).on(c2, (e4, t2) => t2).reset(f2);
    if (e3) {
      let { hooks: t2 } = e3;
      i({ target: [t2.store, t2.store, t2.event, t2.event, t2.event], params: [p3, d3, c2, f2, i3] });
    }
    return s2.open = c2, s2.close = f2, s2.status = p3, s2.state = d3, s2.set = i3, t(`Gate:${l2}`, s2);
  })(m2(d2, e2));
}
var E = (e2) => {
  throw Error(e2);
};
var { useSyncExternalStore: N } = import_shim.default;
var { useSyncExternalStoreWithSelector: R } = import_with_selector.default;
var M = (e2, t2) => t2 ? t2.getState(e2) : e2.getState();
var O2 = (e2, t2) => e2 !== t2;
var L = import_react.default.createContext(null);
var { Provider: U } = L;
var K = "undefined" != typeof window ? import_react.default.useLayoutEffect : import_react.default.useEffect;
var V = (e2) => console.error(`${e2} is deprecated`);
var B = (e2, n2, r2) => (V("createContextComponent"), t(`${e2.shortName || "Unknown"}.ContextComponent`, (t2) => {
  let o2 = import_react.default.useContext(n2), u2 = s(e2);
  return r2(t2, u2, o2);
}));
var I = (e2) => (n2) => {
  let r2 = e2;
  return "function" != typeof e2 && (r2 = n2, n2 = e2), t(`Connect(${r2.displayName || r2.name || "Unknown"})`, (e3) => import_react.default.createElement(r2, { ...e3, ...s(n2) }));
};
var P = (e2, t2) => (V("createReactState"), I(t2)(e2));
var z = (e2) => "object" == typeof e2 && null !== e2;
var F = (e2, t2 = {}) => (z(e2) && (F(e2.or, t2), ((e3) => {
  for (let o2 in e3)
    r2 = o2, ((e4) => void 0 === e4)(n2 = e3[o2]) || "or" === r2 || "and" === r2 || (t2[r2] = n2);
  var n2, r2;
})(e2), F(e2.and, t2)), t2);
export {
  U as Provider,
  I as connect,
  c as createComponent,
  B as createContextComponent,
  y as createGate,
  P as createReactState,
  f as createStoreConsumer,
  u as useEvent,
  d2 as useGate,
  i2 as useList,
  s as useStore,
  l as useStoreMap,
  a2 as useUnit
};
/*! Bundled license information:

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=effector-react.js.map
