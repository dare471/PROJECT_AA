"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.debounce = debounce;
var _effector = require("effector");
function debounce({
  source,
  timeout,
  target
}) {
  if (!_effector.is.unit(source)) throw new TypeError('source must be unit from effector');
  if (_effector.is.domain(source, {
    sid: "jnxv16"
  })) throw new TypeError('source cannot be domain');
  const $timeout = toStoreNumber(timeout);
  const saveTimeoutId = (0, _effector.createEvent)({
    name: "saveTimeoutId",
    sid: "f7vear"
  });
  const $timeoutId = (0, _effector.createStore)(null, {
    and: {
      serialize: 'ignore'
    },
    name: "$timeoutId",
    sid: "-50jqki"
  }).on(saveTimeoutId, (_, id) => id);
  const saveReject = (0, _effector.createEvent)({
    name: "saveReject",
    sid: "-5595t"
  });
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  const $rejecter = (0, _effector.createStore)(null, {
    and: {
      serialize: 'ignore'
    },
    name: "$rejecter",
    sid: "u7x1h9"
  }).on(saveReject, (_, rj) => rj);
  const tick = target !== null && target !== void 0 ? target : (0, _effector.createEvent)({
    name: "tick",
    sid: "-6fizi7"
  });
  const timerBaseFx = (0, _effector.createEffect)(({
    timeout,
    timeoutId,
    rejectPromise
  }) => {
    if (timeoutId) clearTimeout(timeoutId);
    if (rejectPromise) rejectPromise();
    return new Promise((resolve, reject) => {
      saveReject(reject);
      saveTimeoutId(setTimeout(resolve, timeout));
    });
  }, {
    name: "timerBaseFx",
    sid: "-ww7mc3"
  });
  const timerFx = (0, _effector.attach)({
    and: {
      source: {
        timeoutId: $timeoutId,
        rejectPromise: $rejecter
      },
      mapParams: (timeout, {
        timeoutId,
        rejectPromise
      }) => {
        return {
          timeout,
          timeoutId,
          rejectPromise
        };
      },
      effect: timerBaseFx
    },
    or: {
      name: "timerFx",
      sid: "-4ab544"
    }
  });
  $rejecter.reset(timerFx.done);
  $timeoutId.reset(timerFx.done);

  // It's ok - nothing will ever start unless source is triggered
  const $payload = (0, _effector.createStore)([], {
    and: {
      serialize: 'ignore'
    },
    name: "$payload",
    sid: "-5sqiq6"
  }).on(source, (_, payload) => [payload]);
  const $canTick = (0, _effector.createStore)(true, {
    and: {
      serialize: 'ignore'
    },
    name: "$canTick",
    sid: "-ytfpys"
  });
  const triggerTick = (0, _effector.createEvent)({
    name: "triggerTick",
    sid: "aamdmm"
  });
  $canTick.on(triggerTick, () => false).on([tick,
  // debounce timeout should be restarted on timeout change
  $timeout,
  // debounce timeout can be restarted in later ticks
  timerFx], () => true);
  const requestTick = (0, _effector.merge)([source,
  // debounce timeout is restarted on timeout change
  $timeout], {
    name: "requestTick",
    sid: "-8mwak3"
  });
  (0, _effector.guard)({
    and: [{
      clock: requestTick,
      filter: $canTick,
      target: triggerTick
    }],
    or: {
      sid: "-2h4urv"
    }
  });
  (0, _effector.sample)({
    and: [{
      source: $timeout,
      clock: triggerTick,
      target: timerFx
    }],
    or: {
      sid: "-22aer4"
    }
  });
  (0, _effector.sample)({
    and: [{
      source: $payload,
      clock: timerFx.done,
      fn: ([payload]) => payload,
      target: tick
    }],
    or: {
      sid: "-1nfyqd"
    }
  });
  return tick;
}
function toStoreNumber(value) {
  if (_effector.is.store(value, {
    sid: "-15ujnd"
  })) return value;
  if (typeof value === 'number') {
    if (value < 0 || !Number.isFinite(value)) throw new Error(`timeout must be positive number or zero. Received: "${value}"`);
    return (0, _effector.createStore)(value, {
      and: {
        name: '$timeout'
      },
      sid: "-x71bft"
    });
  }
  throw new TypeError(`timeout parameter in interval method should be number or Store. "${typeof value}" was passed`);
}