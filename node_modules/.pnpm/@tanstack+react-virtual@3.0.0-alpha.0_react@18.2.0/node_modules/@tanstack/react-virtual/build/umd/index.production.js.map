{"version":3,"file":"index.production.js","sources":["../../../../node_modules/@reach/observe-rect/dist/observe-rect.esm.js","../../src/useIsomorphicLayoutEffect.ts","../../src/useRect.ts","../../src/index.tsx"],"sourcesContent":["var props = [\"bottom\", \"height\", \"left\", \"right\", \"top\", \"width\"];\n\nvar rectChanged = function rectChanged(a, b) {\n  if (a === void 0) {\n    a = {};\n  }\n\n  if (b === void 0) {\n    b = {};\n  }\n\n  return props.some(function (prop) {\n    return a[prop] !== b[prop];\n  });\n};\n\nvar observedNodes = /*#__PURE__*/new Map();\nvar rafId;\n\nvar run = function run() {\n  var changedStates = [];\n  observedNodes.forEach(function (state, node) {\n    var newRect = node.getBoundingClientRect();\n\n    if (rectChanged(newRect, state.rect)) {\n      state.rect = newRect;\n      changedStates.push(state);\n    }\n  });\n  changedStates.forEach(function (state) {\n    state.callbacks.forEach(function (cb) {\n      return cb(state.rect);\n    });\n  });\n  rafId = window.requestAnimationFrame(run);\n};\n\nfunction observeRect(node, cb) {\n  return {\n    observe: function observe() {\n      var wasEmpty = observedNodes.size === 0;\n\n      if (observedNodes.has(node)) {\n        observedNodes.get(node).callbacks.push(cb);\n      } else {\n        observedNodes.set(node, {\n          rect: undefined,\n          hasRectChanged: false,\n          callbacks: [cb]\n        });\n      }\n\n      if (wasEmpty) run();\n    },\n    unobserve: function unobserve() {\n      var state = observedNodes.get(node);\n\n      if (state) {\n        // Remove the callback\n        var index = state.callbacks.indexOf(cb);\n        if (index >= 0) state.callbacks.splice(index, 1); // Remove the node reference\n\n        if (!state.callbacks.length) observedNodes[\"delete\"](node); // Stop the loop\n\n        if (!observedNodes.size) cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\n\nexport default observeRect;\n//# sourceMappingURL=observe-rect.esm.js.map\n","import * as React from 'react'\n\nexport const useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n","import React from 'react'\nimport observeRect from '@reach/observe-rect'\nimport { useIsomorphicLayoutEffect } from './useIsomorphicLayoutEffect'\n\nexport interface Rect {\n  width: number\n  height: number\n}\n\nfunction rectReducer(state: Rect, action: { rect: Rect }) {\n  const rect = action.rect\n  if (state.height !== rect.height || state.width !== rect.width) {\n    return rect\n  }\n  return state\n}\n\nexport const useRect = <T extends HTMLElement>(\n  nodeRef: React.RefObject<T>,\n  initialRect: Rect = { width: 0, height: 0 },\n) => {\n  const [element, setElement] = React.useState(nodeRef.current)\n  const [rect, dispatch] = React.useReducer(rectReducer, initialRect)\n\n  const initialRectSet = React.useRef(false)\n\n  useIsomorphicLayoutEffect(() => {\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current)\n    }\n  })\n\n  useIsomorphicLayoutEffect(() => {\n    if (element && !initialRectSet.current) {\n      initialRectSet.current = true\n      const rect = element.getBoundingClientRect()\n      dispatch({ rect })\n    }\n  }, [element])\n\n  React.useEffect(() => {\n    if (!element) {\n      return\n    }\n\n    const observer = observeRect(element, (rect) => {\n      dispatch({ rect })\n    })\n\n    observer.observe()\n\n    return () => {\n      observer.unobserve()\n    }\n  }, [element])\n\n  return rect\n}\n","import * as React from 'react'\nimport { useRect, Rect } from './useRect'\nimport { useIsomorphicLayoutEffect } from './useIsomorphicLayoutEffect'\n\nconst defaultEstimateSize = () => 50\n\nconst defaultKeyExtractor = (index: number) => index\n\nconst defaultMeasureSize = (el: HTMLElement, horizontal: boolean) => {\n  const key = horizontal ? 'offsetWidth' : 'offsetHeight'\n\n  return el[key]\n}\n\ntype ScrollAlignment = 'start' | 'center' | 'end' | 'auto'\n\ninterface ScrollToOptions {\n  align: ScrollAlignment\n}\n\ninterface ScrollToOffsetOptions extends ScrollToOptions {}\n\ninterface ScrollToIndexOptions extends ScrollToOptions {}\n\nexport interface Range {\n  start: number\n  end: number\n  overscan: number\n  size: number\n}\n\nexport const defaultRangeExtractor = (range: Range) => {\n  const start = Math.max(range.start - range.overscan, 0)\n  const end = Math.min(range.end + range.overscan, range.size - 1)\n\n  const arr = []\n\n  for (let i = start; i <= end; i++) {\n    arr.push(i)\n  }\n\n  return arr\n}\n\ntype Key = number | string\n\ninterface Item {\n  key: Key\n  index: number\n  start: number\n  end: number\n  size: number\n}\n\nexport interface VirtualItem extends Item {\n  measureRef: (el: HTMLElement | null) => void\n}\n\nexport interface Options<T> {\n  size: number\n  parentRef: React.RefObject<T>\n  estimateSize?: (index: number) => number\n  overscan?: number\n  horizontal?: boolean\n  scrollToFn?: (\n    offset: number,\n    defaultScrollToFn?: (offset: number) => void,\n  ) => void\n  paddingStart?: number\n  paddingEnd?: number\n  useObserver?: (ref: React.RefObject<T>, initialRect?: Rect) => Rect\n  initialRect?: Rect\n  keyExtractor?: (index: number) => Key\n  onScrollElement?: React.RefObject<HTMLElement>\n  scrollOffsetFn?: (event?: Event) => number\n  rangeExtractor?: (range: Range) => number[]\n  measureSize?: (el: HTMLElement, horizontal: boolean) => number\n}\n\nexport const useVirtual = <T extends HTMLElement>({\n  size = 0,\n  estimateSize = defaultEstimateSize,\n  overscan = 1,\n  paddingStart = 0,\n  paddingEnd = 0,\n  parentRef,\n  horizontal = false,\n  scrollToFn,\n  useObserver,\n  initialRect,\n  onScrollElement,\n  scrollOffsetFn,\n  keyExtractor = defaultKeyExtractor,\n  measureSize = defaultMeasureSize,\n  rangeExtractor = defaultRangeExtractor,\n}: Options<T>) => {\n  const sizeKey = horizontal ? 'width' : 'height'\n  const scrollKey = horizontal ? 'scrollLeft' : 'scrollTop'\n\n  const latestRef = React.useRef<{\n    scrollOffset: number\n    measurements: Item[]\n    outerSize: number\n    totalSize: number\n  }>({\n    outerSize: 0,\n    scrollOffset: 0,\n    measurements: [],\n    totalSize: 0,\n  })\n\n  const [scrollOffset, setScrollOffset] = React.useState(0)\n  latestRef.current.scrollOffset = scrollOffset\n\n  const useMeasureParent = useObserver || useRect\n\n  const { [sizeKey]: outerSize } = useMeasureParent(parentRef, initialRect)\n\n  latestRef.current.outerSize = outerSize\n\n  const defaultScrollToFn = React.useCallback(\n    (offset: number) => {\n      if (parentRef.current) {\n        parentRef.current[scrollKey] = offset\n      }\n    },\n    [parentRef, scrollKey],\n  )\n\n  const resolvedScrollToFn = scrollToFn || defaultScrollToFn\n\n  const scrollTo = React.useCallback(\n    (offset: number) => {\n      resolvedScrollToFn(offset, defaultScrollToFn)\n    },\n    [defaultScrollToFn, resolvedScrollToFn],\n  )\n\n  const [measuredCache, setMeasuredCache] = React.useState<Record<Key, number>>(\n    {},\n  )\n\n  const measure = React.useCallback(() => setMeasuredCache({}), [])\n\n  const pendingMeasuredCacheIndexesRef = React.useRef<number[]>([])\n\n  const measurements = React.useMemo(() => {\n    const min =\n      pendingMeasuredCacheIndexesRef.current.length > 0\n        ? Math.min(...pendingMeasuredCacheIndexesRef.current)\n        : 0\n    pendingMeasuredCacheIndexesRef.current = []\n\n    const measurements = latestRef.current.measurements.slice(0, min)\n\n    for (let i = min; i < size; i++) {\n      const key = keyExtractor(i)\n      const measuredSize = measuredCache[key]\n      const start = measurements[i - 1] ? measurements[i - 1].end : paddingStart\n      const size =\n        typeof measuredSize === 'number' ? measuredSize : estimateSize(i)\n      const end = start + size\n      measurements[i] = { index: i, start, size, end, key }\n    }\n    return measurements\n  }, [estimateSize, measuredCache, paddingStart, size, keyExtractor])\n\n  const totalSize = (measurements[size - 1]?.end || paddingStart) + paddingEnd\n\n  latestRef.current.measurements = measurements\n  latestRef.current.totalSize = totalSize\n\n  const element = onScrollElement ? onScrollElement.current : parentRef.current\n\n  const scrollOffsetFnRef = React.useRef(scrollOffsetFn)\n  scrollOffsetFnRef.current = scrollOffsetFn\n\n  useIsomorphicLayoutEffect(() => {\n    if (!element) {\n      setScrollOffset(0)\n\n      return\n    }\n\n    const onScroll = (event?: Event) => {\n      const offset = scrollOffsetFnRef.current\n        ? scrollOffsetFnRef.current(event)\n        : element[scrollKey]\n\n      setScrollOffset(offset)\n    }\n\n    onScroll()\n\n    element.addEventListener('scroll', onScroll, {\n      capture: false,\n      passive: true,\n    })\n\n    return () => {\n      element.removeEventListener('scroll', onScroll)\n    }\n  }, [element, scrollKey])\n\n  const { start, end } = calculateRange(latestRef.current)\n\n  const indexes = React.useMemo(\n    () =>\n      rangeExtractor({\n        start,\n        end,\n        overscan,\n        size: measurements.length,\n      }),\n    [start, end, overscan, measurements.length, rangeExtractor],\n  )\n\n  const measureSizeRef = React.useRef(measureSize)\n  measureSizeRef.current = measureSize\n\n  const virtualItems: VirtualItem[] = React.useMemo(() => {\n    const virtualItems = []\n\n    for (let k = 0, len = indexes.length; k < len; k++) {\n      const i = indexes[k]\n      const measurement = measurements[i]\n\n      const item = {\n        ...measurement,\n        measureRef: (el: HTMLElement | null) => {\n          if (el) {\n            const measuredSize = measureSizeRef.current(el, horizontal)\n\n            if (measuredSize !== item.size) {\n              const { scrollOffset } = latestRef.current\n\n              if (item.start < scrollOffset) {\n                defaultScrollToFn(scrollOffset + (measuredSize - item.size))\n              }\n\n              pendingMeasuredCacheIndexesRef.current.push(i)\n\n              setMeasuredCache((old) => ({\n                ...old,\n                [item.key]: measuredSize,\n              }))\n            }\n          }\n        },\n      }\n\n      virtualItems.push(item)\n    }\n\n    return virtualItems\n  }, [indexes, defaultScrollToFn, horizontal, measurements])\n\n  const mountedRef = React.useRef(false)\n\n  useIsomorphicLayoutEffect(() => {\n    if (mountedRef.current) {\n      setMeasuredCache({})\n    }\n    mountedRef.current = true\n  }, [estimateSize])\n\n  const scrollToOffset = React.useCallback(\n    (\n      toOffset: number,\n      { align }: ScrollToOffsetOptions = { align: 'start' },\n    ) => {\n      const { scrollOffset, outerSize } = latestRef.current\n\n      if (align === 'auto') {\n        if (toOffset <= scrollOffset) {\n          align = 'start'\n        } else if (toOffset >= scrollOffset + outerSize) {\n          align = 'end'\n        } else {\n          align = 'start'\n        }\n      }\n\n      if (align === 'start') {\n        scrollTo(toOffset)\n      } else if (align === 'end') {\n        scrollTo(toOffset - outerSize)\n      } else if (align === 'center') {\n        scrollTo(toOffset - outerSize / 2)\n      }\n    },\n    [scrollTo],\n  )\n\n  const tryScrollToIndex = React.useCallback(\n    (\n      index: number,\n      { align, ...rest }: ScrollToIndexOptions = { align: 'auto' },\n    ) => {\n      const { measurements, scrollOffset, outerSize } = latestRef.current\n\n      const measurement = measurements[Math.max(0, Math.min(index, size - 1))]\n\n      if (!measurement) {\n        return\n      }\n\n      if (align === 'auto') {\n        if (measurement.end >= scrollOffset + outerSize) {\n          align = 'end'\n        } else if (measurement.start <= scrollOffset) {\n          align = 'start'\n        } else {\n          return\n        }\n      }\n\n      const toOffset =\n        align === 'center'\n          ? measurement.start + measurement.size / 2\n          : align === 'end'\n          ? measurement.end\n          : measurement.start\n\n      scrollToOffset(toOffset, { align, ...rest })\n    },\n    [scrollToOffset, size],\n  )\n\n  const scrollToIndex = React.useCallback(\n    (index: number, options?: ScrollToIndexOptions) => {\n      // We do a double request here because of\n      // dynamic sizes which can cause offset shift\n      // and end up in the wrong spot. Unfortunately,\n      // we can't know about those dynamic sizes until\n      // we try and render them. So double down!\n      tryScrollToIndex(index, options)\n      requestAnimationFrame(() => {\n        tryScrollToIndex(index, options)\n      })\n    },\n    [tryScrollToIndex],\n  )\n\n  return {\n    virtualItems,\n    totalSize,\n    scrollToOffset,\n    scrollToIndex,\n    measure,\n  }\n}\n\nconst findNearestBinarySearch = (\n  low: number,\n  high: number,\n  getCurrentValue: (i: number) => number,\n  value: number,\n) => {\n  while (low <= high) {\n    let middle = ((low + high) / 2) | 0\n    let currentValue = getCurrentValue(middle)\n\n    if (currentValue < value) {\n      low = middle + 1\n    } else if (currentValue > value) {\n      high = middle - 1\n    } else {\n      return middle\n    }\n  }\n\n  if (low > 0) {\n    return low - 1\n  } else {\n    return 0\n  }\n}\n\nfunction calculateRange({\n  measurements,\n  outerSize,\n  scrollOffset,\n}: {\n  measurements: Item[]\n  outerSize: number\n  scrollOffset: number\n}) {\n  const size = measurements.length - 1\n  const getOffset = (index: number) => measurements[index].start\n\n  let start = findNearestBinarySearch(0, size, getOffset, scrollOffset)\n  let end = start\n\n  while (end < size && measurements[end].end < scrollOffset + outerSize) {\n    end++\n  }\n\n  return { start, end }\n}\n"],"names":["rafId","props","observedNodes","Map","run","changedStates","forEach","state","node","a","b","newRect","getBoundingClientRect","rect","some","prop","push","callbacks","cb","window","requestAnimationFrame","useIsomorphicLayoutEffect","React","useLayoutEffect","useEffect","rectReducer","action","height","width","useRect","nodeRef","initialRect","useState","current","element","setElement","useReducer","dispatch","initialRectSet","useRef","observer","observe","wasEmpty","size","has","get","set","undefined","hasRectChanged","unobserve","index","indexOf","splice","length","cancelAnimationFrame","defaultEstimateSize","defaultKeyExtractor","defaultMeasureSize","el","horizontal","defaultRangeExtractor","range","start","Math","max","overscan","end","min","arr","i","estimateSize","paddingStart","paddingEnd","parentRef","scrollToFn","useObserver","onScrollElement","scrollOffsetFn","keyExtractor","measureSize","rangeExtractor","sizeKey","scrollKey","latestRef","outerSize","scrollOffset","measurements","totalSize","setScrollOffset","defaultScrollToFn","useCallback","offset","resolvedScrollToFn","scrollTo","measuredCache","setMeasuredCache","measure","pendingMeasuredCacheIndexesRef","useMemo","slice","key","measuredSize","scrollOffsetFnRef","onScroll","event","addEventListener","capture","passive","removeEventListener","low","high","getCurrentValue","value","middle","currentValue","findNearestBinarySearch","calculateRange","indexes","measureSizeRef","virtualItems","k","len","item","measureRef","old","mountedRef","scrollToOffset","toOffset","align","tryScrollToIndex","rest","measurement","scrollToIndex","options"],"mappings":"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"}