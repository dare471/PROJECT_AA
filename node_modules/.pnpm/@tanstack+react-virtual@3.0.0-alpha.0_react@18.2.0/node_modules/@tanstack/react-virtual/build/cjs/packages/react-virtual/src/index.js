/**
 * react-virtual
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('../../../_virtual/_rollupPluginBabelHelpers.js');
var React = require('react');
var useRect = require('./useRect.js');
var useIsomorphicLayoutEffect = require('./useIsomorphicLayoutEffect.js');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);

var _excluded = ["align"];

var defaultEstimateSize = function defaultEstimateSize() {
  return 50;
};

var defaultKeyExtractor = function defaultKeyExtractor(index) {
  return index;
};

var defaultMeasureSize = function defaultMeasureSize(el, horizontal) {
  var key = horizontal ? 'offsetWidth' : 'offsetHeight';
  return el[key];
};

var defaultRangeExtractor = function defaultRangeExtractor(range) {
  var start = Math.max(range.start - range.overscan, 0);
  var end = Math.min(range.end + range.overscan, range.size - 1);
  var arr = [];

  for (var _i = start; _i <= end; _i++) {
    arr.push(_i);
  }

  return arr;
};
var useVirtual = function useVirtual(_ref) {
  var _measurements;

  var _ref$size = _ref.size,
      size = _ref$size === void 0 ? 0 : _ref$size,
      _ref$estimateSize = _ref.estimateSize,
      estimateSize = _ref$estimateSize === void 0 ? defaultEstimateSize : _ref$estimateSize,
      _ref$overscan = _ref.overscan,
      overscan = _ref$overscan === void 0 ? 1 : _ref$overscan,
      _ref$paddingStart = _ref.paddingStart,
      paddingStart = _ref$paddingStart === void 0 ? 0 : _ref$paddingStart,
      _ref$paddingEnd = _ref.paddingEnd,
      paddingEnd = _ref$paddingEnd === void 0 ? 0 : _ref$paddingEnd,
      parentRef = _ref.parentRef,
      _ref$horizontal = _ref.horizontal,
      horizontal = _ref$horizontal === void 0 ? false : _ref$horizontal,
      scrollToFn = _ref.scrollToFn,
      useObserver = _ref.useObserver,
      initialRect = _ref.initialRect,
      onScrollElement = _ref.onScrollElement,
      scrollOffsetFn = _ref.scrollOffsetFn,
      _ref$keyExtractor = _ref.keyExtractor,
      keyExtractor = _ref$keyExtractor === void 0 ? defaultKeyExtractor : _ref$keyExtractor,
      _ref$measureSize = _ref.measureSize,
      measureSize = _ref$measureSize === void 0 ? defaultMeasureSize : _ref$measureSize,
      _ref$rangeExtractor = _ref.rangeExtractor,
      rangeExtractor = _ref$rangeExtractor === void 0 ? defaultRangeExtractor : _ref$rangeExtractor;
  var sizeKey = horizontal ? 'width' : 'height';
  var scrollKey = horizontal ? 'scrollLeft' : 'scrollTop';
  var latestRef = React__namespace.useRef({
    outerSize: 0,
    scrollOffset: 0,
    measurements: [],
    totalSize: 0
  });

  var _React$useState = React__namespace.useState(0),
      scrollOffset = _React$useState[0],
      setScrollOffset = _React$useState[1];

  latestRef.current.scrollOffset = scrollOffset;
  var useMeasureParent = useObserver || useRect.useRect;

  var _useMeasureParent = useMeasureParent(parentRef, initialRect),
      outerSize = _useMeasureParent[sizeKey];

  latestRef.current.outerSize = outerSize;
  var defaultScrollToFn = React__namespace.useCallback(function (offset) {
    if (parentRef.current) {
      parentRef.current[scrollKey] = offset;
    }
  }, [parentRef, scrollKey]);
  var resolvedScrollToFn = scrollToFn || defaultScrollToFn;
  var scrollTo = React__namespace.useCallback(function (offset) {
    resolvedScrollToFn(offset, defaultScrollToFn);
  }, [defaultScrollToFn, resolvedScrollToFn]);

  var _React$useState2 = React__namespace.useState({}),
      measuredCache = _React$useState2[0],
      setMeasuredCache = _React$useState2[1];

  var measure = React__namespace.useCallback(function () {
    return setMeasuredCache({});
  }, []);
  var pendingMeasuredCacheIndexesRef = React__namespace.useRef([]);
  var measurements = React__namespace.useMemo(function () {
    var min = pendingMeasuredCacheIndexesRef.current.length > 0 ? Math.min.apply(Math, pendingMeasuredCacheIndexesRef.current) : 0;
    pendingMeasuredCacheIndexesRef.current = [];
    var measurements = latestRef.current.measurements.slice(0, min);

    for (var _i2 = min; _i2 < size; _i2++) {
      var key = keyExtractor(_i2);
      var measuredSize = measuredCache[key];

      var _start = measurements[_i2 - 1] ? measurements[_i2 - 1].end : paddingStart;

      var _size = typeof measuredSize === 'number' ? measuredSize : estimateSize(_i2);

      var _end = _start + _size;

      measurements[_i2] = {
        index: _i2,
        start: _start,
        size: _size,
        end: _end,
        key: key
      };
    }

    return measurements;
  }, [estimateSize, measuredCache, paddingStart, size, keyExtractor]);
  var totalSize = (((_measurements = measurements[size - 1]) == null ? void 0 : _measurements.end) || paddingStart) + paddingEnd;
  latestRef.current.measurements = measurements;
  latestRef.current.totalSize = totalSize;
  var element = onScrollElement ? onScrollElement.current : parentRef.current;
  var scrollOffsetFnRef = React__namespace.useRef(scrollOffsetFn);
  scrollOffsetFnRef.current = scrollOffsetFn;
  useIsomorphicLayoutEffect.useIsomorphicLayoutEffect(function () {
    if (!element) {
      setScrollOffset(0);
      return;
    }

    var onScroll = function onScroll(event) {
      var offset = scrollOffsetFnRef.current ? scrollOffsetFnRef.current(event) : element[scrollKey];
      setScrollOffset(offset);
    };

    onScroll();
    element.addEventListener('scroll', onScroll, {
      capture: false,
      passive: true
    });
    return function () {
      element.removeEventListener('scroll', onScroll);
    };
  }, [element, scrollKey]);

  var _calculateRange = calculateRange(latestRef.current),
      start = _calculateRange.start,
      end = _calculateRange.end;

  var indexes = React__namespace.useMemo(function () {
    return rangeExtractor({
      start: start,
      end: end,
      overscan: overscan,
      size: measurements.length
    });
  }, [start, end, overscan, measurements.length, rangeExtractor]);
  var measureSizeRef = React__namespace.useRef(measureSize);
  measureSizeRef.current = measureSize;
  var virtualItems = React__namespace.useMemo(function () {
    var virtualItems = [];

    var _loop = function _loop(k, len) {
      var i = indexes[k];
      var measurement = measurements[i];

      var item = _rollupPluginBabelHelpers["extends"]({}, measurement, {
        measureRef: function measureRef(el) {
          if (el) {
            var measuredSize = measureSizeRef.current(el, horizontal);

            if (measuredSize !== item.size) {
              var _scrollOffset = latestRef.current.scrollOffset;

              if (item.start < _scrollOffset) {
                defaultScrollToFn(_scrollOffset + (measuredSize - item.size));
              }

              pendingMeasuredCacheIndexesRef.current.push(i);
              setMeasuredCache(function (old) {
                var _extends2;

                return _rollupPluginBabelHelpers["extends"]({}, old, (_extends2 = {}, _extends2[item.key] = measuredSize, _extends2));
              });
            }
          }
        }
      });

      virtualItems.push(item);
    };

    for (var k = 0, len = indexes.length; k < len; k++) {
      _loop(k);
    }

    return virtualItems;
  }, [indexes, defaultScrollToFn, horizontal, measurements]);
  var mountedRef = React__namespace.useRef(false);
  useIsomorphicLayoutEffect.useIsomorphicLayoutEffect(function () {
    if (mountedRef.current) {
      setMeasuredCache({});
    }

    mountedRef.current = true;
  }, [estimateSize]);
  var scrollToOffset = React__namespace.useCallback(function (toOffset, _temp) {
    var _ref2 = _temp === void 0 ? {
      align: 'start'
    } : _temp,
        align = _ref2.align;

    var _latestRef$current = latestRef.current,
        scrollOffset = _latestRef$current.scrollOffset,
        outerSize = _latestRef$current.outerSize;

    if (align === 'auto') {
      if (toOffset <= scrollOffset) {
        align = 'start';
      } else if (toOffset >= scrollOffset + outerSize) {
        align = 'end';
      } else {
        align = 'start';
      }
    }

    if (align === 'start') {
      scrollTo(toOffset);
    } else if (align === 'end') {
      scrollTo(toOffset - outerSize);
    } else if (align === 'center') {
      scrollTo(toOffset - outerSize / 2);
    }
  }, [scrollTo]);
  var tryScrollToIndex = React__namespace.useCallback(function (index, _temp2) {
    var _ref3 = _temp2 === void 0 ? {
      align: 'auto'
    } : _temp2,
        align = _ref3.align,
        rest = _rollupPluginBabelHelpers.objectWithoutPropertiesLoose(_ref3, _excluded);

    var _latestRef$current2 = latestRef.current,
        measurements = _latestRef$current2.measurements,
        scrollOffset = _latestRef$current2.scrollOffset,
        outerSize = _latestRef$current2.outerSize;
    var measurement = measurements[Math.max(0, Math.min(index, size - 1))];

    if (!measurement) {
      return;
    }

    if (align === 'auto') {
      if (measurement.end >= scrollOffset + outerSize) {
        align = 'end';
      } else if (measurement.start <= scrollOffset) {
        align = 'start';
      } else {
        return;
      }
    }

    var toOffset = align === 'center' ? measurement.start + measurement.size / 2 : align === 'end' ? measurement.end : measurement.start;
    scrollToOffset(toOffset, _rollupPluginBabelHelpers["extends"]({
      align: align
    }, rest));
  }, [scrollToOffset, size]);
  var scrollToIndex = React__namespace.useCallback(function (index, options) {
    // We do a double request here because of
    // dynamic sizes which can cause offset shift
    // and end up in the wrong spot. Unfortunately,
    // we can't know about those dynamic sizes until
    // we try and render them. So double down!
    tryScrollToIndex(index, options);
    requestAnimationFrame(function () {
      tryScrollToIndex(index, options);
    });
  }, [tryScrollToIndex]);
  return {
    virtualItems: virtualItems,
    totalSize: totalSize,
    scrollToOffset: scrollToOffset,
    scrollToIndex: scrollToIndex,
    measure: measure
  };
};

var findNearestBinarySearch = function findNearestBinarySearch(low, high, getCurrentValue, value) {
  while (low <= high) {
    var middle = (low + high) / 2 | 0;
    var currentValue = getCurrentValue(middle);

    if (currentValue < value) {
      low = middle + 1;
    } else if (currentValue > value) {
      high = middle - 1;
    } else {
      return middle;
    }
  }

  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};

function calculateRange(_ref4) {
  var measurements = _ref4.measurements,
      outerSize = _ref4.outerSize,
      scrollOffset = _ref4.scrollOffset;
  var size = measurements.length - 1;

  var getOffset = function getOffset(index) {
    return measurements[index].start;
  };

  var start = findNearestBinarySearch(0, size, getOffset, scrollOffset);
  var end = start;

  while (end < size && measurements[end].end < scrollOffset + outerSize) {
    end++;
  }

  return {
    start: start,
    end: end
  };
}

exports.defaultRangeExtractor = defaultRangeExtractor;
exports.useVirtual = useVirtual;
//# sourceMappingURL=index.js.map
