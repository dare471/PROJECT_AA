import * as effector from 'effector';
import * as solid_js_types_reactive_signal from 'solid-js/types/reactive/signal';
import { Component } from 'solid-js';

/**
 * Creates model `factory`
 * @param creator Function that returns new `model` instance
 * @returns Factory with `createModel` method, `useModel` hook and model `Provider`
 */
declare const modelFactory: <T extends (...args: any[]) => any>(creator: T) => {
    /** Function that returns new `model` instance */
    createModel: T;
    /** Hook that returns current `model` instance */
    useModel: () => NonNullable<ReturnType<T>>;
    /** `Provider` to pass current `model` instance into */
    Provider: solid_js_types_reactive_signal.ContextProviderComponent<ReturnType<T>>;
    '@@unitShape': () => { [key in (NonNullable<ReturnType<T>> extends infer T_1 ? { [Key in keyof T_1]-?: NonNullable<ReturnType<T>>[Key] extends effector.Unit<unknown> ? Key : never; } : never)[keyof NonNullable<ReturnType<T>>] extends infer T_2 ? T_2 extends (NonNullable<ReturnType<T>> extends infer T_1 ? { [Key in keyof T_1]-?: NonNullable<ReturnType<T>>[Key] extends effector.Unit<unknown> ? Key : never; } : never)[keyof NonNullable<ReturnType<T>>] ? T_2 extends `$${infer Unprefixed}` ? Unprefixed : T_2 : never : never]: { [P in (NonNullable<ReturnType<T>> extends infer T_1 ? { [Key in keyof T_1]-?: NonNullable<ReturnType<T>>[Key] extends effector.Unit<unknown> ? Key : never; } : never)[keyof NonNullable<ReturnType<T>>]]: NonNullable<ReturnType<T>>[P]; } extends infer T_3 ? T_3 extends { [P in (NonNullable<ReturnType<T>> extends infer T_1 ? { [Key in keyof T_1]-?: NonNullable<ReturnType<T>>[Key] extends effector.Unit<unknown> ? Key : never; } : never)[keyof NonNullable<ReturnType<T>>]]: NonNullable<ReturnType<T>>[P]; } ? T_3 extends { [inner in key]: unknown; } ? T_3[key] : key extends string ? T_3[`$${key}`] : never : never : never; };
};
type Model<Factory extends ReturnType<typeof modelFactory>> = ReturnType<Factory['createModel']>;
/**
 * HOC that wraps your `View` into model `Provider`. Also adds `model` prop that will be passed into `Provider`
 * @param factory Factory that will be passed through Context
 * @param View Root component that will be wrapped into Context
 * @returns Wrapped component
 */
declare const modelView: <U extends {}, T extends {
    /** Function that returns new `model` instance */
    createModel: (...args: any[]) => any;
    /** Hook that returns current `model` instance */
    useModel: () => any;
    /** `Provider` to pass current `model` instance into */
    Provider: solid_js_types_reactive_signal.ContextProviderComponent<any>;
    '@@unitShape': () => {
        [x: string]: any;
    };
}>(factory: T, View: Component<U & {
    model: ReturnType<T["createModel"]>;
}>) => Component<U & {
    model: ReturnType<T["createModel"]>;
}>;

export { Model, modelFactory, modelView };
